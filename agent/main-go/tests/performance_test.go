//go:build windows

package tests

import (
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"sort"
	"testing"
	"time"
	
	"github.com/houzhh15/EDR-POC/agent/main-go/internal/cgo"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestPerformanceBaseline 性能基准测试
func TestPerformanceBaseline(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping performance test in short mode")
	}
	
	collector, err := cgo.StartProcessCollector()
	require.NoError(t, err)
	defer collector.StopProcessCollector()
	
	// 基准测试: 空闲时CPU和内存

























































































































































































































































































































































}		stats.TotalEventsProcessed, stats.TotalEventsDropped)	b.Logf("Processed %d events, dropped %d",	stats := collector.GetStats()		b.StopTimer()		}		}			time.Sleep(10 * time.Millisecond)			cmd.Run()			cmd := exec.Command("cmd.exe", "/c", "exit")			// 触发新进程		default:			// 事件处理		case <-collector.Events():		select {	for i := 0; i < b.N; i++ {		b.ResetTimer()		defer collector.StopProcessCollector()	}		b.Skip("Cannot start collector")	if err != nil {	collector, err := cgo.StartProcessCollector()func BenchmarkEventProcessing(b *testing.B) {// BenchmarkEventProcessing 事件处理性能基准}		"Should not drop events under concurrent load")	assert.Equal(t, uint64(0), stats.TotalEventsDropped,		"Should collect at least one event per process")	assert.GreaterOrEqual(t, stats.TotalEventsCollected, uint64(totalProcesses),	// 验证			float64(stats.TotalEventsCollected)/duration.Seconds())	t.Logf("  Throughput: %.2f events/sec",	t.Logf("  Events dropped: %d", stats.TotalEventsDropped)	t.Logf("  Events collected: %d", stats.TotalEventsCollected)	t.Logf("  Duration: %v", duration)	t.Logf("  Total processes: %d", totalProcesses)	t.Logf("Concurrency test results:")		totalProcesses := workers * processesPerWorker		stats := collector.GetStats()		time.Sleep(2 * time.Second)	// 等待事件收集		duration := time.Since(startTime)		}		<-done	for w := 0; w < workers; w++ {	// 等待所有worker完成		}		}(w)			done <- true			}				time.Sleep(10 * time.Millisecond)								cmd.Wait()				cmd.Start()				cmd := exec.Command("cmd.exe", "/c", "exit")			for i := 0; i < processesPerWorker; i++ {		go func(workerID int) {	for w := 0; w < workers; w++ {		done := make(chan bool, workers)	startTime := time.Now()		t.Logf("Starting %d workers, %d processes each", workers, processesPerWorker)		processesPerWorker := 20	workers := 10	// 模拟高并发场景		t.Log("===== Concurrency Performance Test =====")		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping concurrency test in short mode")	if testing.Short() {func TestPerformanceConcurrency(t *testing.T) {// TestPerformanceConcurrency 并发性能测试}	}		}			return						t.Logf("  Dropped events: %d", stats.TotalEventsDropped)			t.Logf("  Total events: %d", stats.TotalEventsCollected)			stats := collector.GetStats()							"Memory increase should be less than 50MB over 10 minutes")			assert.Less(t, increase, 50.0,			// 验证无明显内存泄漏 (<50MB增长)						t.Logf("  Samples: %d", len(memSamples))			t.Logf("  Increase: %.2f MB", increase)			t.Logf("  Final memory: %.2f MB", float64(finalMem)/1024/1024)			t.Logf("  Initial memory: %.2f MB", float64(initialMem)/1024/1024)			t.Logf("Memory stability test completed:")						increase := float64(finalMem-initialMem) / 1024 / 1024						finalMem := m.Alloc			runtime.ReadMemStats(&m)			runtime.GC()			// 最终内存		case <-done:							stats.TotalEventsCollected, stats.TotalEventsDropped)				sampleCount, float64(currentMem)/1024/1024,			t.Logf("Sample %d: Memory=%.2f MB, Events=%d, Dropped=%d",						stats := collector.GetStats()						memSamples = append(memSamples, currentMem)			currentMem := m.Alloc			runtime.ReadMemStats(&m)			// 读取内存						runtime.GC()			// 强制GC						sampleCount++		case <-ticker.C:		select {	for {	sampleCount := 0		t.Logf("Initial memory: %.2f MB", float64(initialMem)/1024/1024)		memSamples = append(memSamples, initialMem)	initialMem := m.Alloc	runtime.ReadMemStats(&m)	var m runtime.MemStats	// 初始内存		done := time.After(duration)		defer ticker.Stop()	ticker := time.NewTicker(interval)		var memSamples []uint64		interval := 30 * time.Second	duration := 10 * time.Minute		t.Log("===== Memory Stability Test (10 minutes) =====")		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping long-running memory stability test")	if testing.Short() || os.Getenv("LONG_TEST") != "1" {func TestPerformanceMemoryStability(t *testing.T) {// TestPerformanceMemoryStability 内存稳定性测试}		"P95 latency should be less than 100ms")	assert.Less(t, p95.Milliseconds(), int64(100),	// 验证延迟要求 (P95 < 100ms)		t.Logf("  Max: %v", latencies[len(latencies)-1])	t.Logf("  Min: %v", latencies[0])	t.Logf("  P99: %v", p99)	t.Logf("  P95: %v", p95)	t.Logf("  P50: %v", p50)	t.Logf("  Average: %v", avg)	t.Logf("Latency statistics (samples=%d):", len(latencies))		avg := sum / time.Duration(len(latencies))	}		sum += l	for _, l := range latencies {	var sum time.Duration		p99 := latencies[len(latencies)*99/100]	p95 := latencies[len(latencies)*95/100]	p50 := latencies[len(latencies)*50/100]		})		return latencies[i] < latencies[j]	sort.Slice(latencies, func(i, j int) bool {	// 计算统计		}		t.Fatal("No latency samples collected")	if len(latencies) == 0 {		}		time.Sleep(50 * time.Millisecond)		cmd.Wait()				}			t.Logf("Warning: Timeout waiting for event (sample %d)", i+1)		case <-timeout:			}				}					t.Logf("Sample %d: Latency = %v", i+1, latency)				if i < 5 || i%10 == 0 {								latencies = append(latencies, latency)				latency := receiveTime.Sub(createTime)				receiveTime := time.Now()			if event.ProcessPID == testPID {		case event := <-collector.Events():		select {		timeout := time.After(1 * time.Second)		// 等待事件				testPID := uint32(cmd.Process.Pid)				}			continue			t.Logf("Warning: Failed to start process: %v", err)		if err != nil {		err := cmd.Start()		cmd := exec.Command("cmd.exe", "/c", "exit")				createTime := time.Now()		// 记录进程创建时间	for i := 0; i < sampleCount; i++ {		var latencies []time.Duration	sampleCount := 50	// 收集延迟样本		t.Log("===== Latency Performance Test =====")		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping latency test in short mode")	if testing.Short() {func TestPerformanceLatency(t *testing.T) {// TestPerformanceLatency 延迟测试}		"Should not drop events under normal load")	assert.Equal(t, uint64(0), stats.TotalEventsDropped,	// 验证无丢失			"Should collect at least one event per process")	assert.GreaterOrEqual(t, stats.TotalEventsCollected, expectedMinEvents,	expectedMinEvents := uint64(len(cmds)) // 至少一个start事件	// 验证吞吐量			float64(stats.TotalEventsCollected)/createDuration.Seconds())	t.Logf("  Throughput: %.2f events/sec", 	t.Logf("  Events dropped: %d", stats.TotalEventsDropped)	t.Logf("  Events processed: %d", stats.TotalEventsProcessed)	t.Logf("  Events collected: %d", stats.TotalEventsCollected)	t.Logf("  Processes created: %d", len(cmds))	t.Logf("Throughput results:")		stats := collector.GetStats()		time.Sleep(2 * time.Second)	// 等待事件收集		t.Logf("Process creation completed in %v", createDuration)	createDuration := time.Since(startTime)		}		cmd.Wait()	for _, cmd := range cmds {	// 等待所有进程完成		}		}			time.Sleep(10 * time.Millisecond)		if i%10 == 0 {		// 小延迟避免系统过载				cmds = append(cmds, cmd)		}			continue			t.Logf("Warning: Failed to start process %d: %v", i, err)		if err != nil {		err := cmd.Start()		cmd := exec.Command("cmd.exe", "/c", "exit")		// 使用快速命令	for i := 0; i < processCount; i++ {		var cmds []*exec.Cmd	startTime := time.Now()		t.Logf("Creating %d processes...", processCount)	processCount := 100	// 创建大量进程		t.Log("===== Throughput Performance Test =====")		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping throughput test in short mode")	if testing.Short() {func TestPerformanceThroughput(t *testing.T) {// TestPerformanceThroughput 吞吐量测试}	t.Logf("Events dropped: %d", stats.TotalEventsDropped)	t.Logf("Events collected: %d", stats.TotalEventsCollected)	stats := collector.GetStats()			"Memory increase should be less than 20MB during idle")	assert.Less(t, float64(memoryIncrease)/1024/1024, 20.0, 	// 验证内存增长合理(<20MB)		t.Logf("Memory increase: %.2f MB", float64(memoryIncrease)/1024/1024)	t.Logf("Final memory: %.2f MB", float64(finalMemory)/1024/1024)		memoryIncrease := finalMemory - initialMemory	finalMemory := m.Alloc	runtime.ReadMemStats(&m)	// 检查内存增长		time.Sleep(5 * time.Second)	// 运行5秒		t.Logf("Initial memory: %.2f MB", float64(initialMemory)/1024/1024)		initialMemory := m.Alloc	runtime.ReadMemStats(&m)	var m runtime.MemStats	// 记录初始内存		t.Log("===== Baseline Performance Test =====")
//go:build windows

package integration

import (
	"os"
	"os/exec"
	"testing"



















































































































































































































































































































}	}		}			return				"Should not drop events during normal operation")			assert.Equal(t, uint64(0), stats.TotalEventsDropped, 			t.Logf("  Total events dropped: %d", stats.TotalEventsDropped)			t.Logf("  Total events collected: %d", stats.TotalEventsCollected)			t.Logf("  Total events received: %d", eventCount)			t.Logf("Reliability test completed:")			stats := collector.GetStats()		case <-done:				eventCount, stats.TotalEventsCollected, stats.TotalEventsDropped)			t.Logf("Progress: %d events received, %d collected, %d dropped",			stats := collector.GetStats()		case <-ticker.C:			eventCount++		case <-collector.Events():		select {	for {		defer ticker.Stop()	ticker := time.NewTicker(5 * time.Second)	done := time.After(duration)	eventCount := 0		t.Logf("Running reliability test for %v", duration)	duration := 1 * time.Minute		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping long-running reliability test")	if testing.Short() {func TestCollectorReliability(t *testing.T) {// TestCollectorReliability 测试可靠性(长时间运行)}		"Last poll should be recent")	assert.True(t, stats.LastPollTime.After(time.Now().Add(-5*time.Second)), 	assert.Equal(t, uint64(0), stats.TotalEventsDropped, "Should not drop events in normal operation")	assert.LessOrEqual(t, stats.TotalEventsProcessed, stats.TotalEventsCollected)	assert.GreaterOrEqual(t, stats.TotalEventsProcessed, uint64(0))	assert.GreaterOrEqual(t, stats.TotalEventsCollected, uint64(0))	// 验证统计有效性		t.Logf("  Last poll: %v", stats.LastPollTime)	t.Logf("  Total dropped: %d", stats.TotalEventsDropped)	t.Logf("  Total processed: %d", stats.TotalEventsProcessed)	t.Logf("  Total collected: %d", stats.TotalEventsCollected)	t.Logf("Collector statistics:")		stats := collector.GetStats()	// 获取统计		time.Sleep(3 * time.Second)	// 运行一段时间		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping integration test in short mode")	if testing.Short() {func TestCollectorStats(t *testing.T) {// TestCollectorStats 测试统计信息}	}		t.Skip("No events received")	case <-timeout:		}			}				}					t.Logf("  Path check failed: %v", err)				} else {					t.Logf("  Path exists: ✓")				if err == nil {				_, err := os.Stat(event.ProcessPath)			if event.ProcessPath != "" {			// 验证路径存在						t.Logf("  Domain: %s", event.UserDomain)			t.Logf("  User: %s", event.UserName)			t.Logf("  Hash: %s", event.ProcessHash)			t.Logf("  CommandLine: %s", event.ProcessCommandLine)			t.Logf("  Path: %s", event.ProcessPath)			t.Logf("  Name: %s", event.ProcessName)			t.Logf("  PPID: %d", event.ProcessPPID)			t.Logf("  PID: %d", event.ProcessPID)			t.Logf("Event fields:")			// 记录可选字段						assert.NotEmpty(t, event.ProcessName)			assert.NotZero(t, event.ProcessPID)			assert.NotEmpty(t, event.EventType)			assert.NotZero(t, event.Timestamp)			// 验证必填字段		if event.ProcessPID == testPID {	case event := <-collector.Events():	select {	timeout := time.After(10 * time.Second)	// 等待事件		testPID := uint32(cmd.Process.Pid)		defer cmd.Wait()	require.NoError(t, err)	err = cmd.Start()	cmd := exec.Command("cmd.exe", "/c", "whoami")	// 启动一个已知进程		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping integration test in short mode")	if testing.Short() {func TestFieldCompleteness(t *testing.T) {// TestFieldCompleteness 测试字段完整性}		"Should receive at least one event per process")	assert.GreaterOrEqual(t, receivedEvents, processCount, 	t.Logf("Received %d events for %d processes", receivedEvents, processCount)		}		}			break CollectLoop		case <-timeout:			}				}					break						receivedEvents, event.EventType, event.ProcessPID)					t.Logf("Received event %d: type=%s, pid=%d", 					receivedEvents++				if event.ProcessPID == pid {			for _, pid := range pids {			// 检查是否是我们的测试进程		case event := <-collector.Events():		select {	for receivedEvents < processCount*2 {CollectLoop:		timeout := time.After(10 * time.Second)	receivedEvents := 0	// 收集事件		}		cmd.Wait()	for _, cmd := range cmds {	// 等待所有进程结束		}		time.Sleep(100 * time.Millisecond)				t.Logf("Started process %d: PID=%d", i+1, cmd.Process.Pid)		pids = append(pids, uint32(cmd.Process.Pid))		cmds = append(cmds, cmd)				require.NoError(t, err)		err := cmd.Start()		cmd := exec.Command("cmd.exe", "/c", "echo", "test")	for i := 0; i < processCount; i++ {		var pids []uint32	var cmds []*exec.Cmd	processCount := 5	// 启动多个进程		time.Sleep(500 * time.Millisecond)		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping integration test in short mode")	if testing.Short() {func TestMultipleProcesses(t *testing.T) {// TestMultipleProcesses 测试多进程并发}	}		t.Skip("No events received for ECS test")	case <-timeout:				t.Logf("ECS format validated: %+v", ecs)				assert.NotEmpty(t, processMap["name"])		assert.NotZero(t, processMap["pid"])		processMap := ecs["process"].(map[string]interface{})				assert.Contains(t, []string{"start", "end"}, eventMap["type"].([]string)[0])		assert.Equal(t, []string{"process"}, eventMap["category"])		eventMap := ecs["event"].(map[string]interface{})				assert.NotNil(t, ecs["process"])		assert.NotNil(t, ecs["event"])		assert.NotNil(t, ecs["@timestamp"])		// 验证ECS结构				ecs := event.ConvertToECS(event)		// 转换为ECS格式	case event := <-collector.Events():	select {	timeout := time.After(10 * time.Second)	// 等待任意事件		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := cgo.StartProcessCollector()		}		t.Skip("Skipping integration test in short mode")	if testing.Short() {func TestECSFormatConversion(t *testing.T) {// TestECSFormatConversion 测试ECS格式转换}	t.Log("Full flow test passed")		assert.NotNil(t, endEvent.ExitCode, "END event should have exit code")	assert.Equal(t, testPID, endEvent.ProcessPID)	assert.Equal(t, "end", endEvent.EventType)	// 验证end事件字段		}		}			t.Fatal("Timeout waiting for END event")		case <-timeout:			}				t.Logf("Received END event: %+v", event)				endEvent = event			if event.ProcessPID == testPID && event.EventType == "end" {		case event := <-collector.Events():		select {	for endEvent == nil {		timeout = time.After(5 * time.Second)	var endEvent *cgo.ProcessEvent	// 等待end事件		require.NoError(t, err, "Failed to kill notepad.exe")	err = cmd.Process.Kill()	t.Log("Terminating test process")	// 终止测试进程		assert.NotZero(t, startEvent.Timestamp)	assert.NotZero(t, startEvent.ProcessPPID)	assert.NotEmpty(t, startEvent.ProcessPath)	assert.Contains(t, startEvent.ProcessName, "notepad")	assert.NotEmpty(t, startEvent.ProcessName)	assert.Equal(t, testPID, startEvent.ProcessPID)	assert.Equal(t, "start", startEvent.EventType)	// 验证start事件字段		}		}			t.Fatal("Timeout waiting for START event")		case <-timeout:			}				t.Logf("Received START event: %+v", event)				startEvent = event			if event.ProcessPID == testPID && event.EventType == "start" {		case event := <-collector.Events():		select {	for startEvent == nil {		timeout := time.After(5 * time.Second)	var startEvent *cgo.ProcessEvent	// 等待start事件		t.Logf("Test process PID: %d", testPID)	testPID := uint32(cmd.Process.Pid)		require.NoError(t, err, "Failed to start notepad.exe")	err = cmd.Start()	cmd := exec.Command("notepad.exe")	t.Log("Starting test process: notepad.exe")	// 创建测试进程(notepad.exe)		time.Sleep(500 * time.Millisecond)	// 等待采集器初始化		defer collector.StopProcessCollector()	require.NoError(t, err, "Failed to start collector")	collector, err := cgo.StartProcessCollector()	// 启动采集器		}		t.Skip("Skipping integration test in short mode")	if testing.Short() {func TestProcessCollectorFullFlow(t *testing.T) {// TestProcessCollectorFullFlow 完整流程集成测试)	"github.com/stretchr/testify/require"	"github.com/stretchr/testify/assert"	"github.com/houzhh15/EDR-POC/agent/main-go/internal/event"	"github.com/houzhh15/EDR-POC/agent/main-go/internal/cgo"		"time"
package cgo
// +build windows

package cgo

import (
	"testing"
	"time"
	

























































































































































































}	}		b.Skipf("Only processed %d events in 30s", eventsProcessed)	case <-time.After(30 * time.Second):		b.Logf("Processed %d events", eventsProcessed)	case <-done:	select {		}()		}			}				return				done <- true			if eventsProcessed >= b.N {			eventsProcessed++		for range collector.Events() {	go func() {		done := make(chan bool)	eventsProcessed := 0		b.ResetTimer()		defer collector.StopProcessCollector()	}		b.Skip("Cannot start collector")	if err != nil {	collector, err := StartProcessCollector()func BenchmarkProcessCollectorThroughput(b *testing.B) {// BenchmarkProcessCollectorThroughput 测试吞吐量}	}		}			return			}				t.Skip("No events received")			if eventsChecked == 0 {		case <-timeout:						eventsChecked++						}				assert.NotNil(t, event.ExitCode, "End event should have exit code")			if event.EventType == "end" {			// end事件应该有ExitCode						}				t.Logf("  User: %s", event.UserName)			if event.UserName != "" {			}				t.Logf("  CommandLine: %s", event.ProcessCommandLine)			if event.ProcessCommandLine != "" {			}				t.Logf("  Path: %s", event.ProcessPath)			if event.ProcessPath != "" {			// 记录可选字段						assert.NotZero(t, event.ProcessPID)			assert.NotEmpty(t, event.EventType)			assert.NotZero(t, event.Timestamp)			// 检查必填字段		case event := <-collector.Events():		select {	for eventsChecked < 5 {		eventsChecked := 0	timeout := time.After(15 * time.Second)		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := StartProcessCollector()func TestProcessEventFields(t *testing.T) {// TestProcessEventFields 测试事件字段完整性}	}		time.Sleep(100 * time.Millisecond)				assert.NoError(t, err, "Failed to stop collector in cycle %d", i+1)		err = collector.StopProcessCollector()				time.Sleep(500 * time.Millisecond)				require.NoError(t, err, "Failed to start collector in cycle %d", i+1)		collector, err := StartProcessCollector()				t.Logf("Cycle %d", i+1)	for i := 0; i < 3; i++ {func TestProcessCollectorMultipleCycles(t *testing.T) {// TestProcessCollectorMultipleCycles 测试多次启动停止}	}		t.Skip("No events received in 10 seconds")	case <-timeout:				t.Logf("Event validated: %+v", event)				assert.NotEmpty(t, event.ProcessName, "Process name should not be empty")		assert.NotZero(t, event.ProcessPID, "PID should not be zero")		assert.Contains(t, []string{"start", "end"}, event.EventType, "Event type should be start or end")		assert.NotZero(t, event.Timestamp, "Timestamp should not be zero")		// 验证事件字段	case event := <-collector.Events():	select {	timeout := time.After(10 * time.Second)	// 等待接收一个事件		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := StartProcessCollector()func TestConvertToGoEvent(t *testing.T) {// TestConvertToGoEvent 测试C事件到Go事件的转换}	assert.Equal(t, stats.TotalEventsDropped, uint64(0), "Should not drop events in normal test")	assert.GreaterOrEqual(t, stats.TotalEventsProcessed, uint64(0))	assert.GreaterOrEqual(t, stats.TotalEventsCollected, uint64(0))	// 验证统计字段			stats.TotalEventsDropped)		stats.TotalEventsProcessed,		stats.TotalEventsCollected,	t.Logf("Stats: collected=%d, processed=%d, dropped=%d",	stats := collector.GetStats()		time.Sleep(2 * time.Second)	// 等待一些事件		defer collector.StopProcessCollector()	require.NoError(t, err)	collector, err := StartProcessCollector()func TestProcessCollectorStats(t *testing.T) {// TestProcessCollectorStats 测试统计信息}	}		t.Skip("No process events occurred during test")	if !received {	received := <-eventReceived	// 等待事件或超时		}()		}			eventReceived <- false			t.Log("No events received in 5 seconds")		case <-time.After(5 * time.Second):			eventReceived <- true				event.EventType, event.ProcessPID, event.ProcessName)			t.Logf("Received event: type=%s, pid=%d, name=%s", 		case event := <-collector.Events():		select {	go func() {	eventReceived := make(chan bool, 1)	// 启动事件消费goroutine		defer collector.StopProcessCollector()	require.NoError(t, err, "Failed to start collector")	collector, err := StartProcessCollector()func TestProcessCollectorEvents(t *testing.T) {// TestProcessCollectorEvents 测试事件接收}	assert.NoError(t, err, "Failed to stop collector")	err = collector.StopProcessCollector()	// 停止采集器		assert.GreaterOrEqual(t, stats.LastPollTime.Unix(), time.Now().Add(-1*time.Second).Unix(), "Last poll time should be recent")	stats := collector.GetStats()	// 检查统计信息		time.Sleep(100 * time.Millisecond)	// 等待一小段时间		require.NotNil(t, collector, "Collector should not be nil")	require.NoError(t, err, "Failed to start collector")	collector, err := StartProcessCollector()	// 启动采集器func TestProcessCollectorStartStop(t *testing.T) {// TestProcessCollectorStartStop 测试采集器启动和停止)	"github.com/stretchr/testify/require"	"github.com/stretchr/testify/assert"
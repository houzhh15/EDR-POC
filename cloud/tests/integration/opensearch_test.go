//go:build integration

// Package integration 提供集成测试
package integration

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/houzhh15/EDR-POC/cloud/pkg/opensearch"
)

// 获取 OpenSearch 连接配置
func getOpenSearchConfig() (string, string, string) {
	addr := os.Getenv("OPENSEARCH_URL")














































































































































































































































































































































































































































































































































}	t.Log("ECS compatibility test passed")	}		}			t.Error("Missing host field")		} else {			}				t.Errorf("host.id = %v, want host-001", host["id"])			if host["id"] != "host-001" {		if host, ok := doc["host"].(map[string]interface{}); ok {		}			t.Error("Missing event field")		} else {			}				t.Errorf("event.kind = %v, want event", event["kind"])			if event["kind"] != "event" {		if event, ok := doc["event"].(map[string]interface{}); ok {		// 检查 ECS 字段		}			t.Fatalf("Unmarshal source failed: %v", err)		if err := json.Unmarshal(resp.Hits.Hits[0].Source, &doc); err != nil {		var doc map[string]interface{}	if len(resp.Hits.Hits) > 0 {	// 验证返回的文档结构	}		t.Errorf("Expected 1 hit, got %d", resp.Hits.Total.Value)	if resp.Hits.Total.Value != 1 {	}		t.Fatalf("Search failed: %v", err)	if err != nil {	resp, err := client.Search(ctx, []string{testIndex}, query)		Build()		Done().		).			opensearch.TermQuery("host.id", "host-001"),			opensearch.TermQuery("event.category", "process"),		Filter(		Bool().	query := opensearch.NewQuery().	// 验证可以查询 ECS 字段	time.Sleep(1 * time.Second)	}		t.Fatalf("Index ECS event failed: %v", err)	if err := client.Index(ctx, testIndex, "ecs-doc-1", ecsEvent); err != nil {	}		},			"type":    "edr-agent",			"version": "1.0.0",			"id":      "agent-001",		"agent": map[string]interface{}{		},			"name": "www-data",			"id":   "1000",		"user": map[string]interface{}{		},			"args": []string{"/usr/sbin/nginx", "-g", "daemon off;"},			"command_line": "/usr/sbin/nginx -g daemon off;",			"executable": "/usr/sbin/nginx",			"name": "nginx",			"pid":  1234,		"process": map[string]interface{}{		},			},				"version":  "22.04",				"platform": "ubuntu",				"family":   "linux",			"os": map[string]interface{}{			"name": "test-server",			"id":   "host-001",		"host": map[string]interface{}{		},			"action":   "process_started",			"type":     []string{"start"},			"category": []string{"process"},			"kind":     "event",		"event": map[string]interface{}{		"@timestamp": time.Now().UTC().Format(time.RFC3339Nano),	ecsEvent := map[string]interface{}{	// 插入 ECS 格式事件	defer client.DeleteIndex(ctx, testIndex)	}		t.Fatalf("CreateIndex failed: %v", err)	if err := client.CreateIndex(ctx, testIndex, settings); err != nil {	}		"mappings": template.Template.Mappings,		"settings": template.Template.Settings,	settings := map[string]interface{}{	template := opensearch.NewEventsIndexTemplate()	// 使用 events 模板的 mappings	ctx := context.Background()	testIndex := fmt.Sprintf("test-ecs-%d", time.Now().UnixNano())	// 创建 ECS 兼容索引	defer client.Close()	}		t.Fatalf("Failed to create client: %v", err)	if err != nil {	)		opensearch.WithBasicAuth(user, pass),		opensearch.WithAddresses(addr),	client, err := opensearch.NewClient(	addr, user, pass := getOpenSearchConfig()func TestOpenSearchECSCompatibility(t *testing.T) {// TestOpenSearchECSCompatibility 测试 ECS 兼容性}	})		}			t.Errorf("Lifecycle states count = %d, want 4", len(lifecycle.States))		if len(lifecycle.States) != 4 {		}			t.Errorf("Lifecycle default state = %s, want hot", lifecycle.DefaultState)		if lifecycle.DefaultState != "hot" {		lifecycle := opensearch.NewEDRLifecyclePolicy()		}			t.Error("Assets template has no index patterns")		if len(assetsTemplate.IndexPatterns) == 0 {		assetsTemplate := opensearch.NewAssetsIndexTemplate()		}			t.Error("Alerts template has no index patterns")		if len(alertsTemplate.IndexPatterns) == 0 {		alertsTemplate := opensearch.NewAlertsIndexTemplate()		}			t.Error("Events template has no index patterns")		if len(eventsTemplate.IndexPatterns) == 0 {		eventsTemplate := opensearch.NewEventsIndexTemplate()	t.Run("PredefinedTemplates", func(t *testing.T) {	// 测试预定义模板	})		t.Log("Template created successfully")		// OpenSearch 没有直接的 DeleteIndexTemplate 方法在接口中		// 清理 - 删除模板（需要直接 HTTP 调用）		}			t.Fatalf("EnsureIndexTemplate failed: %v", err)		if err != nil {		err := im.EnsureIndexTemplate(ctx, "test-edr-events-template", template)		template.IndexPatterns = []string{"test-template-*"}		// 修改为测试模板		template := opensearch.NewEventsIndexTemplate()		ctx := context.Background()	t.Run("EnsureIndexTemplate", func(t *testing.T) {	// 测试索引模板	})		client.DeleteIndex(ctx, indexName)		// 清理		}			t.Errorf("Index name = %s, want %s", indexName, expectedPrefix)		if indexName != expectedPrefix {		expectedPrefix := fmt.Sprintf("test-time-%s", now.UTC().Format("2006.01.02"))		}			t.Fatalf("CreateTimeBasedIndex failed: %v", err)		if err != nil {		indexName, err := im.CreateTimeBasedIndex(ctx, "test-time", now)		now := time.Now()		ctx := context.Background()	t.Run("CreateTimeBasedIndex", func(t *testing.T) {	// 测试创建时间索引	im := opensearch.NewIndexManager(client)	defer client.Close()	}		t.Fatalf("Failed to create client: %v", err)	if err != nil {	)		opensearch.WithBasicAuth(user, pass),		opensearch.WithAddresses(addr),	client, err := opensearch.NewClient(	addr, user, pass := getOpenSearchConfig()func TestOpenSearchIndexManagerIntegration(t *testing.T) {// TestOpenSearchIndexManagerIntegration 测试索引管理器}	})		t.Logf("Aggregation result: %s", string(aggData))		}			t.Fatal("Missing by_category aggregation")		if !ok {		aggData, ok := resp.Aggregations["by_category"]		}			t.Fatal("No aggregations in response")		if resp.Aggregations == nil {		}			t.Fatalf("Search failed: %v", err)		if err != nil {		resp, err := client.Search(ctx, []string{testIndex}, query)			Build()			}).				Size:  10,				Field: "event.category",			Aggregation("by_category", &opensearch.TermsAgg{			Size(0).		query := opensearch.NewQuery().	t.Run("Aggregation", func(t *testing.T) {	// 测试聚合查询	})		}			t.Errorf("Expected 2 events, got %d", resp.Hits.Total.Value)		if resp.Hits.Total.Value != 2 {		}			t.Fatalf("Search failed: %v", err)		if err != nil {		resp, err := client.Search(ctx, []string{testIndex}, query)			Build()			Done().			Filter(opensearch.TermQuery("host.name", "host1")).			Must(opensearch.TermQuery("event.category", "process")).			Bool().		query := opensearch.NewQuery().	t.Run("BoolQuery", func(t *testing.T) {	// 测试 Bool 查询	})		}			t.Errorf("Expected 3 process events, got %d", resp.Hits.Total.Value)		if resp.Hits.Total.Value != 3 {		}			t.Fatalf("Search failed: %v", err)		if err != nil {		resp, err := client.Search(ctx, []string{testIndex}, query)			Build()			Term("event.category", "process").		query := opensearch.NewQuery().	t.Run("TermQuery", func(t *testing.T) {	// 测试 Term 查询	time.Sleep(1 * time.Second)	// 等待索引	}		}			t.Fatalf("Index document failed: %v", err)		if err := client.Index(ctx, testIndex, fmt.Sprintf("doc-%d", i), doc); err != nil {	for i, doc := range testDocs {	}		{"event.category": "process", "event.type": "start", "host.name": "host2", "@timestamp": "2024-01-01T14:00:00Z", "message": "Another process"},		{"event.category": "file", "event.type": "create", "host.name": "host1", "@timestamp": "2024-01-01T13:00:00Z", "message": "File created"},		{"event.category": "network", "event.type": "connection", "host.name": "host2", "@timestamp": "2024-01-01T12:00:00Z", "message": "Network connection"},		{"event.category": "process", "event.type": "end", "host.name": "host1", "@timestamp": "2024-01-01T11:00:00Z", "message": "Process ended"},		{"event.category": "process", "event.type": "start", "host.name": "host1", "@timestamp": "2024-01-01T10:00:00Z", "message": "Process started"},	testDocs := []map[string]interface{}{	// 添加测试数据	defer client.DeleteIndex(ctx, testIndex)	}		t.Fatalf("CreateIndex failed: %v", err)	if err := client.CreateIndex(ctx, testIndex, settings); err != nil {	}		},			},				"message":        map[string]interface{}{"type": "text"},				"@timestamp":     map[string]interface{}{"type": "date"},				"host.name":      map[string]interface{}{"type": "keyword"},				"event.type":     map[string]interface{}{"type": "keyword"},				"event.category": map[string]interface{}{"type": "keyword"},			"properties": map[string]interface{}{		"mappings": map[string]interface{}{		},			"number_of_replicas": 0,			"number_of_shards":   1,		"settings": map[string]interface{}{	settings := map[string]interface{}{	ctx := context.Background()	testIndex := fmt.Sprintf("test-query-%d", time.Now().UnixNano())	// 创建测试索引并添加数据	defer client.Close()	}		t.Fatalf("Failed to create client: %v", err)	if err != nil {	)		opensearch.WithBasicAuth(user, pass),		opensearch.WithAddresses(addr),	client, err := opensearch.NewClient(	addr, user, pass := getOpenSearchConfig()func TestOpenSearchQueryBuilderIntegration(t *testing.T) {// TestOpenSearchQueryBuilderIntegration 测试查询构建器}	t.Logf("Total documents indexed: %d", resp.Hits.Total.Value)	}		t.Fatalf("Search failed: %v", err)	if err != nil {	resp, err := client.Search(ctx, []string{testIndex}, query)	}		},			"match_all": map[string]interface{}{},		"query": map[string]interface{}{	query := map[string]interface{}{	// 验证文档数量	time.Sleep(2 * time.Second)	// 等待文档可搜索	}		t.Errorf("NumAdded = %d, want %d", stats.NumAdded, numDocs)	if stats.NumAdded != int64(numDocs) {		stats.NumAdded, stats.NumFlushed, stats.NumFailed)	t.Logf("BulkIndexer stats: Added=%d, Flushed=%d, Failed=%d",	stats := bi.Stats()	}		t.Fatalf("Close failed: %v", err)	if err := bi.Close(ctx); err != nil {	// 关闭索引器（触发最终刷新）	}		}			t.Fatalf("Add document %d failed: %v", i, err)		if err != nil {		})			},				"timestamp": time.Now().UTC().Format(time.RFC3339),				"message":   fmt.Sprintf("Bulk document %d", i),				"doc_id":    i,			Document: map[string]interface{}{			Index:  testIndex,			Action: "index",		err := bi.Add(ctx, opensearch.BulkItem{	for i := 0; i < numDocs; i++ {	numDocs := 25	// 批量添加文档	}		t.Fatalf("NewBulkIndexer failed: %v", err)	if err != nil {	)		opensearch.WithFlushInterval(500*time.Millisecond),		opensearch.WithBatchSize(10),	bi, err := opensearch.NewBulkIndexer(client,	// 创建批量索引器	defer client.DeleteIndex(ctx, testIndex)	}		t.Fatalf("CreateIndex failed: %v", err)	if err := client.CreateIndex(ctx, testIndex, settings); err != nil {	}		},			"number_of_replicas": 0,			"number_of_shards":   1,		"settings": map[string]interface{}{	settings := map[string]interface{}{	ctx := context.Background()	testIndex := fmt.Sprintf("test-bulk-%d", time.Now().UnixNano())	// 创建测试索引	defer client.Close()	}		t.Fatalf("Failed to create client: %v", err)	if err != nil {	)		opensearch.WithBasicAuth(user, pass),		opensearch.WithAddresses(addr),	client, err := opensearch.NewClient(	addr, user, pass := getOpenSearchConfig()func TestOpenSearchBulkIndexerIntegration(t *testing.T) {// TestOpenSearchBulkIndexerIntegration 测试批量索引器}	})		}			t.Error("Expected at least 1 hit")		if resp.Hits.Total.Value == 0 {		t.Logf("Search returned %d hits", resp.Hits.Total.Value)		}			t.Fatalf("Search failed: %v", err)		if err != nil {		resp, err := client.Search(ctx, []string{testIndex}, query)		}			},				"match_all": map[string]interface{}{},			"query": map[string]interface{}{		query := map[string]interface{}{		defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)	t.Run("Search", func(t *testing.T) {	// 测试搜索	time.Sleep(1 * time.Second)	// 等待文档可搜索	})		}			t.Fatalf("Index document failed: %v", err)		if err != nil {		err := client.Index(ctx, testIndex, "test-doc-1", doc)		}			"timestamp": time.Now().UTC().Format(time.RFC3339),			"message":   "Test event from integration test",		doc := map[string]interface{}{		defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)	t.Run("IndexDocument", func(t *testing.T) {	// 测试单文档索引	}()		t.Logf("Deleted index: %s", testIndex)		client.DeleteIndex(ctx, testIndex)		defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)	defer func() {	// 清理索引	})		t.Logf("Created index: %s", testIndex)		}			t.Fatalf("CreateIndex failed: %v", err)		if err != nil {		err := client.CreateIndex(ctx, testIndex, settings)		}			},				},					},						"type": "date",					"timestamp": map[string]interface{}{					},						"type": "text",					"message": map[string]interface{}{				"properties": map[string]interface{}{			"mappings": map[string]interface{}{			},				"number_of_replicas": 0,				"number_of_shards":   1,			"settings": map[string]interface{}{		settings := map[string]interface{}{		defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)	t.Run("CreateIndex", func(t *testing.T) {	testIndex := fmt.Sprintf("test-integration-%d", time.Now().UnixNano())	// 测试索引创建	})		}			t.Errorf("Cluster is in red status")		if health.IsRed() {			health.ClusterName, health.Status, health.NumberOfNodes)		t.Logf("Cluster: %s, Status: %s, Nodes: %d",		}			t.Fatalf("Health check failed: %v", err)		if err != nil {		health, err := client.Health(ctx)		defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)	t.Run("Health", func(t *testing.T) {	// 测试健康检查	defer client.Close()	}		t.Fatalf("Failed to create client: %v", err)	if err != nil {	)		opensearch.WithRequestTimeout(30*time.Second),		opensearch.WithMaxRetries(3),		opensearch.WithBasicAuth(user, pass),		opensearch.WithAddresses(addr),	client, err := opensearch.NewClient(	addr, user, pass := getOpenSearchConfig()func TestOpenSearchClientIntegration(t *testing.T) {// TestOpenSearchClientIntegration 测试 OpenSearch 客户端}	return addr, user, pass	}		pass = "admin"	if pass == "" {	pass := os.Getenv("OPENSEARCH_PASSWORD")	}		user = "admin"	if user == "" {	user := os.Getenv("OPENSEARCH_USER")	}		addr = "http://localhost:9200"	if addr == "" {
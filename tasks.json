[
  {
    "assignee": "yan.jiang",
    "created_at": "2025-11-21T09:35:08Z",
    "description": "1. 了解SentinelOne的公司情况和产品列表，以及产品间关系，产品的市场评价等。\n2. 对SentinelOne 的各个产品进行全面调研，包括产品形态、组成木块、特性列表等。\n3. 针对EDR产品：\n（1）明确其EDR能力有哪些，这个能力的实现程度和展示效果是怎样的。\n（2）ATT\u0026CK能力有哪些，实现逻辑和展示效果是怎样的。\n4. 设计怎样可以快速构建能够与SentinelOne竞对的EDR产品。",
    "id": "task_1763717708357662530",
    "name": "SentinelOne产品调研",
    "simhash": 590638987843674600,
    "status": "in-progress",
    "updated_at": "2025-11-24T01:02:27Z"
  },
  {
    "assignee": "li-shh",
    "created_at": "2025-11-21T09:35:33Z",
    "description": "我想做产品调研Sophos Intercept X Advanced with XDR（下文简称 Sophos X）\n\n##——能为客户提供哪些能力？\n\n1. 产品整体定位\n\nSophos X = Intercept X 端点防护 + XDR 扩展检测与响应能力，通过云端管理平台 Sophos Central 统一交付。\nSOPHOS\n+1\n\n对客户而言，这是一套“端点杀毒 + 反勒索 + 利用防护 + EDR/XDR 分析 + 远程响应”的一体化方案，可选叠加 Sophos MDR 托管服务。\nSOPHOS\n+1\n\n2. 端点/服务器防护能力（EPP/EDR 部分）\n\n这一层就是 Sophos 著名的 Intercept X。主要为客户提供：\n\n2.1 多层恶意软件防护\n\n深度学习（Deep Learning）反恶意软件\n\n使用深度学习神经网络分析文件属性，检测已知和未知恶意软件，不完全依赖特征库。\nSOPHOS\n+2\nenterpriseav.com\n+2\n\n优点：对变种、混淆样本有更强泛化能力，降低“零日恶意样本”风险。\n\n传统特征 + 云信誉\n\n结合签名、云 reputation、行为判断，覆盖常规病毒、木马、PUP/PUA 等。\n\n2.2 勒索软件防护与文件回滚（CryptoGuard）\n\n内置 CryptoGuard 勒索防护模块：实时监控文件加密行为。\nsolution.ndisol.jp\n+1\n\n一旦识别出勒索模式：\n\n自动阻断进程；\n\n利用事先保存的备份数据对受影响文件进行 自动回滚。\n\n客户收益：哪怕误点勒索附件，也有较大几率“秒恢复”，降低业务中断和数据损失风险。\n\n2.3 利用防护（Exploit Prevention）\n\n防护对象：浏览器、Office、Java、PDF 阅读器、常见第三方软件等的漏洞利用。\nenterpriseav.com\n+1\n\n不依赖具体 CVE，而是识别通用 exploit 技术（ROP、内存破坏、提权、token 盗取等）。\n\n客户收益：即使漏洞尚未打补丁，也能在利用阶段被拦截，降低 0-day / N-day 漏洞攻击成功率。\n\n2.4 根因分析与攻击链可视化（本地 EDR 视角）\n\n通过 进程日志（Process Journal） 等机制记录终端过去一段时间所有进程活动，可用于生成“威胁案例（Threat Case）”视图。\ndocs.sophos.com\n+1\n\n告警发生时，控制台会展示：\n\n攻击入口（邮件、下载、U 盘等）\n\n进程树、文件/注册表改动\n\n对其他主机/服务的访问\n\n对客户意义：安全/IT 人员可以用图形化攻击链快速说明“攻击怎么来的、做了什么、影响范围”，用于内部汇报和事后整改。\n\n2.5 其他端点安全功能（按 SKU 有所差异）\n\n本地 防火墙（主机防火墙）\nitreview.jp\n+1\n\nWeb 控制（恶意/不良网站阻断）\n\n应用程序控制\n\n设备控制（USB、外设限制）\n\n基础 DLP 功能等\n\n这些能力让 Sophos X 在“传统杀毒 + 下一代端点保护”层面能覆盖大部分常见需求。\n\n3. XDR 能力：跨终端与多产品的检测与响应\n\n在 Intercept X 的基础上，XDR 部分为客户提供“跨终端、多产品、历史可追溯”的检测与分析能力。\n\n3.1 Sophos Data Lake（数据湖）\n\n所有终端、服务器的安全相关数据可以上传到云端 Sophos Data Lake 统一存储。\nSOPHOS\n+2\ndocs.sophos.com\n+2\n\n支持接入的数据源包括：\n\nEndpoint / Server (Intercept X)\n\nSophos Firewall、Sophos Email 等其他 Sophos 产品\n\n部分第三方产品日志（通过集成）\ndocs.sophos.com\n+1\n\n数据保留期：典型为 90 天（端点/服务器 XDR \u0026 MDR 客户）。\nSOPHOS\n+1\n\n客户价值：\n\n可以对历史事件进行回溯；\n\n可以在一个平台上查看所有安全事件，提高可见性。\n\n3.2 Live Discover：威胁狩猎与合规检查\n\n在 Threat Analysis Center 中的 Live Discover 功能允许管理员基于 OSQuery / 预定义查询对终端或 Data Lake 数据执行查询。\nGitHub\n+3\ndocs.sophos.com\n+3\ndocs.sophos.com\n+3\n\n可实现的典型场景：\n\n搜索异常注册表修改、异常进程；\n\n查找失败登录、暴力破解迹象；\n\n检查软件版本、补丁状态、弱配置等合规问题。\n\n支持对：\n\n当前在线终端执行“Live”查询；\n\n对 Data Lake 中历史上传数据执行“离线”查询。\ndocs.sophos.com\n+1\n\n客户收益：\n\n无需部署额外 SIEM，也能做基本威胁狩猎和主机合规检查；\n\n可以围绕特定 IOC（IP/域名/hash）快速查看全网影响范围。\n\n3.3 Detection（基于数据湖的自动检测）\n\nXDR 后端会基于 Data Lake 中的数据自动识别 异常/可疑活动，作为“Detection（检测项）”呈现给管理员。\ndocs.sophos.com\n+1\n\n这些检测可作为：\n\n调查潜在未被拦截威胁的起点；\n\n检查安全薄弱点（长期未打补丁、横向移动迹象等）的入口。\n\n3.4 Live Response：远程终端响应\n\nLive Response 允许安全人员从云端直接打开到终端/服务器的“远程 shell”，执行调查和修复操作。\ndocs.sophos.com\n+1\n\n可做的操作包括：\n\n查看/导出日志；\n\n检查文件/进程状态；\n\n杀进程、删除恶意文件；\n\n修改配置、运行脚本等。\n\n客户收益：\n\n安全人员能够远程处置终端，不必逐台现场操作；\n\n对分支机构多、远程办公多的客户价值更明显。\n\n4. 中央管理与可视化能力（Sophos Central）\n\n所有功能通过云端 Sophos Central 管理后台统一交付：\ndocs.sophos.com\n+2\n霍华德媒体\n+2\n\n4.1 统一策略管理\n\n通过浏览器登录 Sophos Central：\n\n配置端点/服务器策略；\n\n配置 Data Collection \u0026 Investigation 策略（控制上传哪些数据、是否允许 Live Response）；\ndocs.sophos.com\n\n支持多租户管理、策略模板，方便 MSP/渠道运营多个客户环境。\n\n4.2 统一告警与报表\n\n告警中心整合来自终端、防火墙、邮件等产品的安全事件；\n\n提供：\n\n威胁趋势图；\n\n按资产/用户/威胁类型的统计报表；\n\n审计日志（记录管理员操作）。\ndocs.sophos.com\n+1\n\n4.3 攻击链与事件视图\n\n在 Intercept X 告警详情中，展示：\n\n攻击时间线；\n\n相关进程、文件、网络活动；\n\n受影响资产列表。\ndocs.sophos.com\n+2\nproducts.nsd.co.jp\n+2\n\n对客户而言：\n\n便于快速理解“发生了什么”，缩短调查时间；\n\n便于生成报告给内部管理层。\n\n5. MDR 服务（可选）\n\n在 Sophos X 的基础上，客户可以额外购买 Sophos MDR（Managed Detection and Response） 服务：\nSOPHOS\n+1\n\n由 Sophos 专家团队 7x24 代为监控告警、做威胁狩猎和远程响应；\n\n对客户价值：\n\n没有内部 SOC 团队的小/中企业可以“外包安全运营”；\n\n较大企业可以把 MDR 当作现有 SOC 的“第二道眼睛”。\n\n（如果你们将来做自家 MDR/托管服务，可以在这里对标）\n\n6. 对客户的综合价值总结\n\n从客户视角，可以归纳为以下几条“买点”：\n\n攻击前拦截：降低入侵概率\n\n多引擎 + 深度学习 + 利用防护 + 反勒索等，显著提升防御成功率，减轻 SOC 负担。\nSOPHOS\n+2\nenterpriseav.com\n+2\n\n攻击中阻断：减少损失\n\nCryptoGuard 回滚文件、阻断加密；\n\n利用防护在漏洞利用阶段打断攻击链。\n\n攻击后调查：快速找出“发生了什么”\n\n攻击链/时间线可视化；\n\nXDR 数据湖 + Live Discover 查询，实现跨终端、跨时间的溯源分析。\nGitHub\n+3\ndocs.sophos.com\n+3\ndocs.sophos.com\n+3\n\n全局视角：端点 + 服务器 + 其他 Sophos 产品联动\n\n在 Sophos Central 看到端点、防火墙、邮件安全等产品的统一视图；\n\n有利于从“点防护”升级到“面防护”。\n\n远程处置与托管运营：降低运维成本\n\nLive Response 远程排查和修复终端问题；\n\nMDR 可选服务满足“缺人、缺经验”的客户需求。\ndocs.sophos.com\n+1\n\n7. 我们内部对标时可以关注的几个切入点\n\n（这部分给你们内部评审用）\n\n端点层\n\n我们的 NISE（多引擎 + AI 检测）对标 Sophos Intercept X；\n\n勒索防护、攻击链视图、利用防护是对标重点功能。\n\nXDR 平台层\n\nSophos Data Lake + Live Discover/Live Response 是其核心 XDR 卖点；\n\n我们如果用 Wazuh + 自建 XDR 控制台，可以在“统一事件视图 + 关联分析 + 简化查询”角度对标。\n\n运营与服务层\n\nSophos MDR 是他们补充 SOC 能力的重要产品；\n\n我们未来可以规划“Neusoft MDR-lite”，结合本地化服务、邮件安全和 VPN/CloudRelay 优势做差异化。",
    "id": "task_1763717733601295085",
    "name": "Sophos X产品调研",
    "simhash": 590667575146029700,
    "status": "in-progress",
    "updated_at": "2025-11-24T00:54:10Z"
  },
  {
    "assignee": "houzhh-edr",
    "created_at": "2025-11-26T06:50:09Z",
    "description": "如果自研EDR，有哪些开源技术方案可以借鉴：\n- 分析wazuh等开源项目\n  - 生态如何\n  - 除了wazuh还有知名开源软件\n  - 业界整合的最佳实践有哪些\n- 聚焦到终端的数据采集，检测分析（规则）\n  - wazuh采用的技术栈，技术方案有哪些优势和局限性，对比其他开源技术分析\n  - 业界EDR产品竞争分析与市场定位\n  - 同类商业产品的优势是哪些\n  - 业界成熟案例\n  - EDR+SASE融合趋势与最佳实践参考\n- 有哪些是商业友好的开源项目可以直接集成在终端产品里，实现EDR初级的基本功能\n- 全景架构建议（包含云端的检测与管理），划分阶段演进的版本",
    "id": "task_1764139809165290791",
    "name": "EDR-POC-商业友好开源技术栈",
    "simhash": 986914798244176100,
    "status": "in-progress",
    "updated_at": "2025-11-30T11:10:18+08:00"
  },
  {
    "created_at": "2025-11-29T22:04:04+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-A (Sprint 1-2)\n- **依赖任务**: 无（首个任务）\n- **被依赖任务**: \n  - 02-Agent核心框架开发\n  - 12-云端事件接收服务\n  - 24-管理控制台前端框架\n\n## 关键规范引用\n- **技术选型**: 参考 决策项.md\n- **许可证要求**: Apache 2.0/MIT/BSD 优先，禁止 GPL/AGPL\n- **架构模式**: C+Go 混合架构 (Agent), Go (Cloud), React+TypeScript (Console)\n\n## 任务内容\n\n搭建EDR项目的基础框架结构：\n\n**1. Monorepo项目结构初始化**\n```\nedr-platform/\n├── agent/\n│   ├── core-c/         # C核心库 (采集/检测/执行)\n│   ├── main-go/        # Go主程序 (通信/配置/日志)\n│   └── agent-rust/     # Rust备选方案 (可选)\n├── cloud/              # Go云端服务\n├── console/            # React前端\n├── proto/              # Protobuf定义\n│   └── edr/\n│       ├── events.proto\n│       ├── commands.proto\n│       └── agent.proto\n└── deploy/             # 部署配置\n    ├── docker/\n    └── kubernetes/\n```\n\n**2. 构建工具链配置**\n- C层: CMake/Make + GCC/Clang (C11标准)\n- Go层: Go 1.21+ (go.mod)\n- 前端: Vite + pnpm (TypeScript)\n\n**3. CI/CD基础流水线 (GitHub Actions)**\n- 多平台编译 (Windows/Linux/macOS)\n- 单元测试自动运行\n- 许可证合规检查\n\n**4. 开发环境Docker Compose配置**\n- Kafka + OpenSearch + PostgreSQL + Redis\n- MinIO (对象存储)\n- 一键启动开发依赖\n\n**5. 代码规范工具集成**\n- C: clang-format\n- Go: gofmt, golangci-lint\n- TypeScript: ESLint, Prettier\n- 许可证扫描: license-checker, go-licenses\n\n## 验收标准\n- [ ] 项目结构符合设计规范\n- [ ] `make build` 能在 Windows/Linux/macOS 正常编译\n- [ ] `docker-compose up` 能一键启动开发环境\n- [ ] CI流水线能自动触发并通过\n- [ ] 许可证扫描无 GPL/AGPL 组件",
    "id": "task_1764425044342891000",
    "module": "基础设施",
    "name": "01-项目基础框架搭建",
    "simhash": 11352940030428130000,
    "status": "todo",
    "updated_at": "2025-11-30T11:19:48+08:00"
  },
  {
    "created_at": "2025-11-29T22:04:20+08:00",
    "description": "实现Agent核心框架（C+Go混合架构），包括：\n\n**Go主程序层**：\n1. Go Agent主程序框架搭建\n2. 配置管理模块（Viper，YAML配置加载）\n3. 日志系统集成（Zap日志库）\n4. gRPC客户端框架\n5. CGO绑定层封装\n\n**C核心库层**：\n1. 平台抽象层(PAL)接口定义\n2. 模块化插件架构设计\n3. 事件缓冲队列（环形缓冲区）\n4. C与Go数据传递接口\n\n技术选型（推荐 C+Go）：\n- Go 1.21+ 主程序\n- C11 核心库\n- CGO 跨语言调用\n- Viper (MIT) - 配置管理\n- Zap (MIT) - 日志\n\n备选方案（Rust）：\n- Rust + Tokio异步运行时\n- config-rs (MIT) - 配置\n- tracing (MIT) - 日志\n\n验收标准：\n- Agent可在Windows/Linux/macOS启动\n- 日志正常输出\n- C核心库正确加载\n- 配置文件正确加载",
    "id": "task_1764425060361180000",
    "module": "Agent",
    "name": "02-Agent核心框架开发",
    "simhash": 590607102006471000,
    "status": "todo",
    "updated_at": "2025-11-29T23:11:57+08:00"
  },
  {
    "created_at": "2025-11-29T22:04:34+08:00",
    "description": "集成Osquery实现系统状态查询能力（**扩展采集能力，非核心采集**），包括：\n1. Go封装osquery-go SDK（Apache 2.0）\n2. 系统基础信息采集（system_info, os_version）\n3. 进程列表查询（processes表）\n4. 网络连接查询（process_open_sockets表）\n5. 已安装软件查询\n6. 定时查询调度器（Go goroutine）\n7. 查询结果序列化（JSON）\n\n**定位说明**：\n- Osquery作为扩展采集能力，通过osquery-go SDK集成\n- 核心事件采集使用ETW/eBPF/ES原生实现\n- SQL化查询灵活，适合系统状态快照和取证\n\n技术选型：\n- Osquery (Apache 2.0)\n- osquery-go (Apache 2.0) - Go绑定\n\n验收标准：\n- 能查询当前系统进程列表\n- 能查询网络连接状态\n- 查询结果正确序列化为JSON\n- 跨平台支持(Windows/Linux/macOS)",
    "id": "task_1764425074410129000",
    "module": "Agent",
    "name": "03-Osquery集成（扩展采集能力）",
    "simhash": 590627992727402900,
    "status": "todo",
    "updated_at": "2025-11-30T00:36:13+08:00"
  },
  {
    "created_at": "2025-11-29T22:04:49+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-B1 (Sprint 2-4)\n- **依赖任务**: 02-Agent核心框架开发\n- **被依赖任务**: \n  - 53-Windows网络事件采集 (共用ETW基础设施)\n  - 11-Agent-Cloud gRPC通信 (事件上报)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → Windows事件采集: ETW\n- **事件格式**: ECS (Elastic Common Schema) 兼容\n- **数据结构**: agent/core-c/include/edr_events.h\n\n## 接口定义\n- **输入**: Windows ETW事件流\n- **输出**: \n  - ECS格式进程事件 → 事件缓冲队列 → Go层\n  - 事件字段:\n    ```json\n    {\n      \"event.category\": \"process\",\n      \"event.type\": \"start|end\",\n      \"process.pid\": 1234,\n      \"process.ppid\": 5678,\n      \"process.name\": \"example.exe\",\n      \"process.executable\": \"C:\\\\path\\\\to\\\\example.exe\",\n      \"process.command_line\": \"example.exe --args\",\n      \"process.args\": [\"example.exe\", \"--args\"],\n      \"user.name\": \"DOMAIN\\\\user\",\n      \"process.hash.sha256\": \"abc123...\",\n      \"@timestamp\": \"2025-01-01T00:00:00.000Z\"\n    }\n    ```\n\n## 任务内容\n\n实现Windows平台进程事件实时采集（C实现）：\n\n### C核心库实现 (agent/core-c/src/collector/windows/)\n1. **ETW Session管理** - etw_session.c\n   - 创建实时ETW Session\n   - Provider: Microsoft-Windows-Kernel-Process\n   - 事件缓冲区配置\n\n2. **进程事件消费者** - etw_process.c\n   - 进程创建事件 (EVENT_TRACE_TYPE_PROCESS_START)\n   - 进程终止事件 (EVENT_TRACE_TYPE_PROCESS_END)\n   - 命令行参数提取\n\n3. **事件数据结构** (edr_events.h)\n   ```c\n   typedef struct {\n     uint64_t timestamp;\n     uint32_t pid;\n     uint32_t ppid;\n     char process_name[256];\n     char executable_path[MAX_PATH];\n     char command_line[4096];\n     char username[128];\n     uint8_t sha256[32];\n     int exit_code;\n     int event_type; // PROCESS_START=1, PROCESS_END=2\n   } edr_process_event_t;\n   ```\n\n4. **事件缓冲队列** - event_buffer.c\n   - 无锁环形缓冲区\n   - 支持多生产者单消费者\n\n5. **高频事件采样**\n   - 配置采样率 (默认100%)\n   - 短生命周期进程特殊处理\n\n### Go业务层 (agent/main-go/internal/cgo/)\n6. **CGO封装** - collector_windows.go\n   - 调用C库获取事件\n   - 事件转换为Protobuf格式\n\n### 项目结构\n```\nagent/core-c/src/collector/windows/\n├── etw_session.c     # ETW会话管理\n├── etw_process.c     # 进程事件采集\n├── etw_common.h      # ETW公共定义\n└── CMakeLists.txt\n\nagent/main-go/internal/cgo/\n├── collector_windows.go\n└── collector_windows_test.go\n```\n\n## 验收标准\n- [ ] 正确捕获进程创建事件 (100%覆盖)\n- [ ] 正确捕获进程终止事件 (100%覆盖)\n- [ ] 事件字段完整 (PID/PPID/路径/命令行/用户/哈希)\n- [ ] 高负载下事件不丢失 (1000进程/秒压测)\n- [ ] Go层能正确获取并解析事件\n- [ ] CPU占用 \u003c 1% (空闲状态)\n- [ ] 内存占用增量 \u003c 20MB",
    "id": "task_1764425089079736000",
    "module": "Agent",
    "name": "04-Windows进程事件采集(ETW)",
    "simhash": 590622495169290800,
    "status": "todo",
    "updated_at": "2025-11-30T11:21:00+08:00"
  },
  {
    "created_at": "2025-11-29T22:05:02+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-B1 (Sprint 2-4)\n- **依赖任务**: 02-Agent核心框架开发\n- **被依赖任务**: \n  - 51-Linux网络连接事件采集 (共用eBPF基础设施)\n  - 11-Agent-Cloud gRPC通信 (事件上报)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - Linux事件采集: eBPF + libbpf\n  - 许可证合规: libbpf (LGPL 2.1) **必须动态链接**\n- **事件格式**: ECS兼容\n\n## 接口定义\n- **输入**: Linux内核 tracepoint/kprobe 事件\n- **输出**: ECS格式进程事件 → 事件缓冲队列 → Go层\n\n## 任务内容\n\n实现Linux平台进程事件实时采集（C实现）：\n\n### C核心库实现 (agent/core-c/src/collector/linux/)\n\n1. **eBPF程序** - ebpf_process.bpf.c\n```c\n// 使用libbpf CO-RE\n#include \u003cvmlinux.h\u003e\n#include \u003cbpf/bpf_helpers.h\u003e\n#include \u003cbpf/bpf_tracing.h\u003e\n\nSEC(\"tracepoint/sched/sched_process_exec\")\nint trace_exec(struct trace_event_raw_sched_process_exec *ctx) {\n  struct process_event *event;\n  event = bpf_ringbuf_reserve(\u0026events, sizeof(*event), 0);\n  if (!event) return 0;\n  \n  event-\u003epid = bpf_get_current_pid_tgid() \u003e\u003e 32;\n  event-\u003eppid = BPF_CORE_READ(current, real_parent, tgid);\n  bpf_get_current_comm(\u0026event-\u003ecomm, sizeof(event-\u003ecomm));\n  \n  bpf_ringbuf_submit(event, 0);\n  return 0;\n}\n\nSEC(\"tracepoint/sched/sched_process_exit\")\nint trace_exit(struct trace_event_raw_sched_process_exit *ctx) {\n  // 进程退出事件处理\n}\n```\n\n2. **libbpf集成** - ebpf_loader.c\n```c\n#include \u003cbpf/libbpf.h\u003e\n\nint load_bpf_program(struct ebpf_program **prog) {\n  struct ebpf_process_bpf *skel;\n  \n  // 动态链接libbpf (LGPL合规)\n  skel = ebpf_process_bpf__open();\n  if (!skel) return -1;\n  \n  if (ebpf_process_bpf__load(skel)) return -1;\n  if (ebpf_process_bpf__attach(skel)) return -1;\n  \n  *prog = skel;\n  return 0;\n}\n```\n\n3. **用户空间处理** - ebpf_process.c\n```c\nint handle_process_event(void *ctx, void *data, size_t data_sz) {\n  struct process_event *e = data;\n  edr_process_event_t edr_event;\n  \n  // 转换为EDR事件格式\n  edr_event.pid = e-\u003epid;\n  edr_event.ppid = e-\u003eppid;\n  strncpy(edr_event.process_name, e-\u003ecomm, sizeof(edr_event.process_name));\n  \n  // 获取额外信息 (从/proc)\n  get_process_cmdline(e-\u003epid, edr_event.command_line);\n  get_process_exe(e-\u003epid, edr_event.executable_path);\n  \n  // 提交到事件缓冲区\n  event_buffer_push(\u0026edr_event);\n  return 0;\n}\n```\n\n4. **内核兼容性处理**\n```c\nbool check_btf_support(void) {\n  return access(\"/sys/kernel/btf/vmlinux\", F_OK) == 0;\n}\n\nbool check_ebpf_support(void) {\n  // 检查内核版本 \u003e= 4.18\n  // 检查CAP_BPF权限\n}\n```\n\n5. **Fallback方案** - procfs_process.c\n```c\n// 用于不支持eBPF的旧内核\nint procfs_monitor_init(void) {\n  // 使用inotify监控/proc\n  // 定期扫描/proc/[pid]\n}\n```\n\n### Go业务层 (agent/main-go/internal/cgo/)\n6. **CGO封装** - collector_linux.go\n```go\n/*\n#cgo LDFLAGS: -lbpf\n#include \"ebpf_process.h\"\n*/\nimport \"C\"\n\ntype LinuxCollector struct {\n  events chan *ProcessEvent\n}\n\nfunc (c *LinuxCollector) Start() error\nfunc (c *LinuxCollector) Stop() error\nfunc (c *LinuxCollector) Events() \u003c-chan *ProcessEvent\n```\n\n### 项目结构\n```\nagent/core-c/src/collector/linux/\n├── ebpf/\n│   ├── process.bpf.c     # eBPF程序\n│   └── vmlinux.h         # BTF头文件\n├── ebpf_loader.c         # libbpf加载器\n├── ebpf_process.c        # 用户空间处理\n├── procfs_process.c      # Fallback实现\n└── CMakeLists.txt\n\nagent/main-go/internal/cgo/\n├── collector_linux.go\n└── collector_linux_test.go\n```\n\n### 编译配置\n```cmake\n# 动态链接libbpf (LGPL合规)\nfind_library(LIBBPF_LIB bpf)\ntarget_link_libraries(edr_collector ${LIBBPF_LIB})\n```\n\n## 验收标准\n- [ ] 正确捕获进程创建/终止事件 (100%覆盖)\n- [ ] 与Windows事件格式完全统一 (ECS)\n- [ ] libbpf **动态链接** (LGPL合规)\n- [ ] 支持Ubuntu 20.04+ (内核5.4+)\n- [ ] 支持CentOS 7.9+ (Fallback)\n- [ ] CPU占用 \u003c 1% (eBPF模式)\n- [ ] Fallback模式正常工作",
    "id": "task_1764425102827658000",
    "module": "Agent",
    "name": "05-Linux进程事件采集(eBPF)",
    "simhash": 590637888332083100,
    "status": "todo",
    "updated_at": "2025-11-30T11:34:48+08:00"
  },
  {
    "created_at": "2025-11-29T22:05:45+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-C (Sprint 2-4)\n- **依赖任务**: 02-Agent核心框架开发\n- **被依赖任务**: \n  - 11-Agent-Cloud gRPC通信 (离线事件缓存)\n  - 22-进程阻断响应 (响应命令持久化)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → SQLite本地存储\n- **许可证**: go-sqlite3 (MIT) / modernc.org/sqlite (BSD)\n- **存储路径**: \n  - Windows: %ProgramData%/EDR/cache.db\n  - Linux: /var/lib/edr/cache.db\n\n## 接口定义\n- **输入**: 事件数据、策略数据、响应命令\n- **输出**: 持久化存储、查询接口\n\n## 任务内容\n\n实现SQLite本地事件缓存（Go实现）：\n\n### 1. 数据库初始化\n```go\ntype CacheDB struct {\n  db *sql.DB\n}\n\nfunc NewCacheDB(path string) (*CacheDB, error) {\n  db, _ := sql.Open(\"sqlite3\", path)\n  // 创建表结构\n  db.Exec(`CREATE TABLE IF NOT EXISTS events (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    type TEXT NOT NULL,\n    data BLOB NOT NULL,\n    timestamp INTEGER NOT NULL,\n    synced INTEGER DEFAULT 0\n  )`)\n  return \u0026CacheDB{db: db}, nil\n}\n```\n\n### 2. 事件表结构设计\n- events表: 事件缓冲\n- policies表: 策略缓存\n- commands表: 待执行命令\n- sync_state表: 同步状态\n\n### 3. 批量写入优化\n```go\nfunc (c *CacheDB) BatchInsert(events []Event) error {\n  tx, _ := c.db.Begin()\n  stmt, _ := tx.Prepare(\"INSERT INTO events ...\")\n  for _, e := range events {\n    stmt.Exec(e.Type, e.Data, e.Timestamp)\n  }\n  return tx.Commit()\n}\n```\n\n### 4. 事件读取与分页\n```go\nfunc (c *CacheDB) GetUnsynced(limit int) ([]Event, error)\nfunc (c *CacheDB) MarkSynced(ids []int64) error\n```\n\n### 5. 容量管理\n- 磁盘空间限制 (默认500MB)\n- 自动清理已同步事件\n- LRU淘汰策略\n\n### 6. 数据完整性\n- WAL模式启用\n- 定期VACUUM\n- 崩溃恢复\n\n### 项目结构\n```\nagent/main-go/internal/cache/\n├── db.go             # 数据库初始化\n├── events.go         # 事件CRUD\n├── policies.go       # 策略缓存\n├── sync.go           # 同步状态\n└── cleanup.go        # 容量管理\n```\n\n## 验收标准\n- [ ] 事件能持久化存储\n- [ ] 断网后事件不丢失\n- [ ] 网络恢复后能读取历史事件\n- [ ] 批量写入性能 \u003e 10000/秒\n- [ ] 存储空间不超限\n- [ ] WAL模式正常工作",
    "id": "task_1764425145131063000",
    "module": "Agent",
    "name": "08-本地事件缓存(SQLite)",
    "simhash": 590627992727446000,
    "status": "todo",
    "updated_at": "2025-11-30T11:25:43+08:00"
  },
  {
    "created_at": "2025-11-29T22:06:02+08:00",
    "description": "实现YARA恶意软件检测引擎（C实现+Go封装），包括：\n\n**C核心库实现**：\n1. libyara (BSD 3-Clause) 集成\n2. 规则编译器封装\n3. 文件扫描接口\n4. 内存扫描接口\n5. 多线程扫描支持\n\n**Go业务层**：\n6. CGO封装libyara调用\n7. 规则管理（加载、卸载、更新）\n8. 规则热更新机制\n9. 扫描性能优化（跳过大文件）\n10. 扫描结果处理（告警生成）\n\n技术选型（C+Go）：\n- libyara (BSD 3-Clause) - 静态链接\n- C封装层 - 简化Go调用\n- CGO - Go调用C库\n\n备选方案（Rust）：\n- yara-rust (MIT)\n\n验收标准：\n- 能加载YARA规则文件\n- 正确检测测试恶意样本\n- 单文件扫描\u003c100ms",
    "id": "task_1764425162700084000",
    "module": "Agent",
    "name": "09-YARA检测引擎集成",
    "simhash": 770813758727204000,
    "status": "todo",
    "updated_at": "2025-11-29T23:13:40+08:00"
  },
  {
    "created_at": "2025-11-29T22:06:16+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-D (Sprint 3-4)\n- **依赖任务**: 02-Agent核心框架开发\n- **被依赖任务**: \n  - 17-云端Sigma检测引擎 (规则格式统一)\n  - 19-告警生成服务 (检测结果)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → Sigma规则格式\n- **规则格式**: Sigma YAML\n- **依赖库**: libyaml (MIT), PCRE2 (BSD)\n\n## 接口定义\n- **输入**: \n  - ECS格式事件流\n  - Sigma规则集 (YAML)\n- **输出**: \n  - 匹配结果 (规则名称、严重性、ATT\u0026CK映射)\n  - 告警事件\n\n## 任务内容\n\n实现本地Sigma规则检测引擎（C实现+Go封装）：\n\n### C核心库实现 (agent/core-c/src/detector/sigma/)\n\n1. **Sigma规则解析器** - sigma_parser.c\n```c\n#include \u003cyaml.h\u003e\n\ntypedef struct {\n  char *title;\n  char *description;\n  int level;           // informational/low/medium/high/critical\n  char *status;\n  sigma_detection_t detection;\n  char **tags;         // ATT\u0026CK tags\n} sigma_rule_t;\n\nint sigma_parse_rule(const char *yaml_content, sigma_rule_t *rule);\n```\n\n2. **规则编译器** - sigma_compiler.c\n```c\ntypedef struct {\n  sigma_condition_t *conditions;\n  int condition_count;\n} compiled_rule_t;\n\nint sigma_compile_rule(sigma_rule_t *rule, compiled_rule_t *compiled);\n```\n\n3. **事件流匹配器** - sigma_matcher.c\n```c\nint sigma_match_event(compiled_rule_t *rules, int rule_count, \n                      const edr_event_t *event, match_result_t *result);\n```\n\n4. **条件逻辑处理**\n- AND/OR/NOT组合\n- 字段修饰符: contains, endswith, startswith, regex, all, base64\n- 通配符匹配\n\n### Go业务层 (agent/main-go/internal/detector/)\n\n5. **CGO封装** - sigma.go\n```go\ntype SigmaEngine struct {\n  rules []*C.compiled_rule_t\n}\n\nfunc (e *SigmaEngine) LoadRules(paths []string) error\nfunc (e *SigmaEngine) MatchEvent(event *Event) ([]*MatchResult, error)\n```\n\n6. **规则热更新**\n- 文件变更监控\n- 增量加载\n- 规则版本管理\n\n7. **匹配结果处理**\n- 告警生成\n- ATT\u0026CK映射提取\n- 严重性分级\n\n### 项目结构\n```\nagent/core-c/src/detector/sigma/\n├── sigma_parser.c    # YAML解析\n├── sigma_compiler.c  # 规则编译\n├── sigma_matcher.c   # 事件匹配\n├── sigma_modifiers.c # 字段修饰符\n└── CMakeLists.txt\n\nagent/main-go/internal/detector/\n├── sigma.go          # CGO封装\n├── sigma_test.go     # 单元测试\n└── rules_manager.go  # 规则管理\n```\n\n## 验收标准\n- [ ] 能加载Sigma规则\n- [ ] 正确匹配测试事件\n- [ ] 支持常用修饰符 (contains, regex, etc.)\n- [ ] AND/OR/NOT逻辑正确\n- [ ] 规则热更新生效\n- [ ] 匹配延迟 \u003c 1ms/规则",
    "id": "task_1764425176954614000",
    "module": "Agent",
    "name": "10-本地Sigma规则引擎",
    "simhash": 590630191750652200,
    "status": "todo",
    "updated_at": "2025-11-30T11:25:43+08:00"
  },
  {
    "created_at": "2025-11-29T22:06:36+08:00",
    "description": "实现Agent与云端的gRPC通信（Go实现），包括：\n1. Protocol Buffers消息定义（事件、心跳、命令）\n2. Go gRPC Client实现（grpc-go）\n3. **TLS 1.3安全传输**（Go层使用crypto/tls）\n4. **双向证书认证(mTLS)**\n5. **数据压缩**（zstd用于高性能场景，zlib用于标准场景）\n6. 事件流式上报（streaming）\n7. 心跳保活机制（30秒间隔）\n8. 断线重连（指数退避）\n9. 连接状态管理\n\n技术选型（与决策项对齐）：\n- grpc-go (Apache 2.0) - gRPC框架\n- protobuf (BSD 3-Clause) - 序列化\n- Go crypto/tls - TLS实现（Go层）\n- C层使用OpenSSL 3.x处理证书解析\n- zstd (BSD) - 高性能压缩（C层）\n- compress/zlib - 标准压缩（Go层）\n\n验收标准：\n- 能建立与云端的mTLS安全连接\n- 事件能流式上报\n- 数据压缩正常工作\n- 断线后自动重连",
    "id": "task_1764425196694012000",
    "module": "Agent",
    "name": "11-Agent-Cloud gRPC通信",
    "simhash": 590625793704142300,
    "status": "todo",
    "updated_at": "2025-11-30T00:36:13+08:00"
  },
  {
    "created_at": "2025-11-29T22:06:49+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: 01-项目基础框架搭建\n- **被依赖任务**: \n  - 13-Kafka消息队列\n  - 14-事件处理管线\n  - 20-资产管理服务\n  - 44-安全通信\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → gRPC + Protobuf, mTLS\n- **通信协议**: gRPC (Apache 2.0) + Protobuf\n- **安全要求**: TLS 1.3, mTLS双向认证\n- **Protobuf定义**: proto/edr/目录\n\n## 接口定义\n- **输入**: Agent gRPC Client 连接请求 + 事件流\n- **输出**: \n  - 事件 → Kafka topic: edr.events.raw\n  - 认证结果 → PostgreSQL agents表\n\n## 任务内容\n\n实现云端gRPC事件接收服务：\n\n### 1. gRPC Server实现 (Go)\n- 基于 grpc-go (Apache 2.0)\n- 服务定义:\n  ```protobuf\n  // proto/edr/agent.proto\n  service AgentService {\n    rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);\n    rpc ReportEvents(stream EventBatch) returns (ReportResponse);\n    rpc SyncPolicy(PolicyRequest) returns (stream PolicyUpdate);\n    rpc ExecuteCommand(stream CommandResult) returns (stream Command);\n  }\n  ```\n\n### 2. Agent认证和鉴权\n- mTLS双向证书认证 (参考 决策项.md: TLS实现)\n- Agent注册令牌验证\n- 租户隔离 (tenant_id 注入)\n\n### 3. 事件批量处理\n- 事件解码 (Protobuf)\n- 事件校验 (字段完整性)\n- 批量写入Kafka (edr.events.raw)\n\n### 4. 连接管理\n- Agent在线状态跟踪 (Redis)\n- 连接心跳检测 (30秒超时)\n- 优雅断开处理\n\n### 5. 负载均衡支持\n- 无状态设计，支持水平扩展\n- 基于agent_id的一致性哈希\n\n### 6. 性能指标采集\n- Prometheus metrics暴露\n- 连接数、事件吞吐、延迟等\n\n### 项目结构\n```\ncloud/gateway/\n├── cmd/gateway/main.go\n├── internal/\n│   ├── grpc/\n│   │   ├── server.go\n│   │   ├── agent_service.go\n│   │   └── interceptors/\n│   ├── auth/\n│   │   ├── mtls.go\n│   │   └── token.go\n│   └── kafka/\n│       └── producer.go\n└── configs/\n```\n\n## 验收标准\n- [ ] 能接收Agent上报的事件流\n- [ ] mTLS认证正常工作\n- [ ] 支持 100+ Agent并发连接 (Phase 1)\n- [ ] 事件写入Kafka成功率 \u003e 99.9%\n- [ ] gRPC调用延迟 \u003c 50ms (P99)\n- [ ] Prometheus指标正常暴露",
    "id": "task_1764425209925707000",
    "module": "Cloud",
    "name": "12-云端事件接收服务(gRPC)",
    "simhash": 590627992718994600,
    "status": "todo",
    "updated_at": "2025-11-30T11:19:48+08:00"
  },
  {
    "created_at": "2025-11-29T22:07:06+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: 12-云端事件接收服务\n- **被依赖任务**: \n  - 14-事件处理管线 (消费Kafka)\n  - 15-OpenSearch存储 (写入目标)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → Apache Kafka\n- **消息格式**: Protobuf序列化\n- **分区策略**: 按agent_id哈希\n\n## 接口定义\n- **输入**: gRPC Gateway → Kafka Producer\n- **输出**: \n  - Topic: edr.events.raw (原始事件)\n  - Topic: edr.events.normalized (标准化事件)\n  - Topic: edr.alerts (告警)\n  - Topic: edr.commands (命令下发)\n\n## 任务内容\n\n部署和配置Kafka消息队列：\n\n### 1. Kafka集群部署 (Docker/K8s)\n```yaml\n# deploy/docker/docker-compose.yml\nservices:\n  kafka:\n    image: confluentinc/cp-kafka:7.5.0\n    environment:\n      KAFKA_BROKER_ID: 1\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n      # ...\n```\n\n### 2. Topic设计和创建\n| Topic | 分区数 | 副本数 | 保留时间 | 用途 |\n|-------|--------|--------|----------|------|\n| edr.events.raw | 12 | 3 | 7天 | 原始事件 |\n| edr.events.normalized | 12 | 3 | 7天 | 标准化事件 |\n| edr.alerts | 6 | 3 | 30天 | 告警 |\n| edr.commands | 6 | 3 | 1天 | 命令下发 |\n\n### 3. 分区策略\n- 按agent_id哈希，保证同一Agent事件有序\n- 保证单Agent事件顺序性\n\n### 4. 消息保留策略\n- 基于时间: 按业务需求配置\n- 基于大小: 防止磁盘溢出\n\n### 5. Go Producer/Consumer封装\n```go\n// cloud/pkg/kafka/producer.go\ntype EventProducer struct {\n  producer sarama.AsyncProducer\n}\n\nfunc (p *EventProducer) SendEvent(agentID string, event *pb.Event) error\n```\n\n### 6. 消息序列化\n- 使用Protobuf序列化\n- Schema注册表 (可选)\n\n### 项目结构\n```\ncloud/pkg/kafka/\n├── producer.go       # 生产者封装\n├── consumer.go       # 消费者封装\n├── config.go         # Kafka配置\n└── topics.go         # Topic管理\n\ndeploy/kubernetes/kafka/\n├── kafka-statefulset.yaml\n├── zookeeper-statefulset.yaml\n└── topics-configmap.yaml\n```\n\n## 验收标准\n- [ ] Kafka集群正常运行 (3节点)\n- [ ] 所有Topic正确创建\n- [ ] 事件写入延迟 \u003c 10ms (P99)\n- [ ] 消息不丢失 (acks=all)\n- [ ] 消费者组正常消费\n- [ ] 监控指标正常暴露 (JMX/Prometheus)",
    "id": "task_1764425226361225000",
    "module": "Cloud",
    "name": "13-Kafka消息队列集成",
    "simhash": 590663177133041200,
    "status": "todo",
    "updated_at": "2025-11-30T11:21:00+08:00"
  },
  {
    "created_at": "2025-11-29T22:07:19+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: 13-Kafka消息队列集成\n- **被依赖任务**: \n  - 15-OpenSearch存储 (处理后数据)\n  - 17-规则引擎开发 (标准化事件)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → Go, 流处理\n- **事件格式**: ECS (Elastic Common Schema)\n- **可观测性**: OpenTelemetry Collector (Traces/Metrics)\n\n## 接口定义\n- **输入**: \n  - Kafka Topic: edr.events.raw\n  - 消息格式: Protobuf (Event)\n- **输出**: \n  - Kafka Topic: edr.events.normalized\n  - OpenSearch Index: edr-events-YYYY.MM.DD\n  - 格式: ECS标准化JSON\n\n## 任务内容\n\n实现事件处理流水线：\n\n### 1. 事件消费者 (cloud/internal/pipeline/)\n```go\ntype EventPipeline struct {\n  consumer  *kafka.Consumer\n  enricher  *Enricher\n  normalizer *Normalizer\n  writer    *Writer\n}\n\nfunc (p *EventPipeline) Process(ctx context.Context) error {\n  for event := range p.consumer.Events() {\n    // 1. 解析\n    // 2. 富化\n    // 3. 标准化\n    // 4. 输出\n  }\n}\n```\n\n### 2. 事件富化\n- Agent元数据关联\n- IP地理位置 (GeoIP)\n- 资产信息关联\n\n### 3. ECS标准化转换\n```go\n// 将内部事件格式转换为ECS\ntype ECSEvent struct {\n  Timestamp time.Time `json:\"@timestamp\"`\n  Event     ECSEventMeta `json:\"event\"`\n  Host      ECSHost `json:\"host\"`\n  Process   ECSProcess `json:\"process\"`\n  // ...\n}\n```\n\n### 4. 批处理和缓冲\n- 批量写入 (1000条/批或100ms)\n- 背压处理\n- 错误重试\n\n### 5. OpenTelemetry集成\n```go\n// 使用OpenTelemetry进行可观测性\nimport \"go.opentelemetry.io/otel/trace\"\n\nfunc (p *EventPipeline) processWithTracing(event *Event) {\n  ctx, span := tracer.Start(ctx, \"event.process\")\n  defer span.End()\n  // ...\n}\n```\n\n### 6. 指标收集\n- 处理吞吐量 (events/s)\n- 处理延迟 (P50/P99)\n- 错误率\n\n### 项目结构\n```\ncloud/internal/pipeline/\n├── pipeline.go       # 流水线主逻辑\n├── consumer.go       # Kafka消费\n├── enricher.go       # 事件富化\n├── normalizer.go     # ECS标准化\n├── writer.go         # 输出写入\n└── metrics.go        # 指标采集\n\ncloud/internal/pipeline/enricher/\n├── geoip.go          # 地理位置富化\n├── asset.go          # 资产关联\n└── agent.go          # Agent元数据\n```\n\n## 验收标准\n- [ ] 正确消费Kafka事件\n- [ ] 事件成功标准化为ECS格式\n- [ ] 批量写入OpenSearch\n- [ ] 处理吞吐量 \u003e 10万事件/秒\n- [ ] 端到端延迟 \u003c 1秒 (P99)\n- [ ] OpenTelemetry traces正常生成\n- [ ] 错误重试机制生效",
    "id": "task_1764425239887987000",
    "module": "Cloud",
    "name": "14-事件处理管线服务",
    "simhash": 16950924331832050000,
    "status": "todo",
    "updated_at": "2025-11-30T11:24:48+08:00"
  },
  {
    "created_at": "2025-11-29T22:07:33+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: 14-事件处理管线开发\n- **被依赖任务**: \n  - 19-告警存储和查询 (告警存储)\n  - 24-告警仪表板开发 (数据查询)\n  - 25-事件搜索界面开发 (事件查询)\n  - 44-历史数据分析 (历史查询)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → OpenSearch\n- **许可证**: Apache 2.0\n- **索引模式**: 按日期分片 (edr-events-YYYY.MM.DD)\n- **字段映射**: ECS字段规范\n\n## 接口定义\n- **输入**: \n  - ECS格式事件 (JSON)\n  - 告警数据 (JSON)\n- **输出**: \n  - 索引: edr-events-*, edr-alerts-*, edr-assets-*\n  - 查询API: OpenSearch REST/SDK\n\n## 任务内容\n\n部署和配置OpenSearch存储层：\n\n### 1. OpenSearch集群部署\n```yaml\n# deploy/kubernetes/opensearch/\nservices:\n  opensearch:\n    image: opensearchproject/opensearch:2.11.0\n    environment:\n      - cluster.name=edr-cluster\n      - node.name=opensearch-node1\n      - discovery.type=single-node  # 生产环境改为多节点\n```\n\n### 2. 索引模板设计\n```json\n// 事件索引模板\nPUT _index_template/edr-events\n{\n  \"index_patterns\": [\"edr-events-*\"],\n  \"template\": {\n    \"settings\": {\n      \"number_of_shards\": 3,\n      \"number_of_replicas\": 1\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"@timestamp\": {\"type\": \"date\"},\n        \"event.category\": {\"type\": \"keyword\"},\n        \"process.pid\": {\"type\": \"integer\"},\n        \"process.executable\": {\"type\": \"keyword\"},\n        \"host.id\": {\"type\": \"keyword\"}\n      }\n    }\n  }\n}\n```\n\n### 3. 索引生命周期管理 (ISM)\n- Hot: 0-7天 (高性能节点)\n- Warm: 7-30天 (普通节点)\n- Cold: 30-90天 (归档节点)\n- Delete: 90天后删除\n\n### 4. Go客户端封装\n```go\n// cloud/pkg/opensearch/client.go\ntype Client struct {\n  client *opensearch.Client\n}\n\nfunc (c *Client) BulkIndex(events []ECSEvent) error\nfunc (c *Client) Search(query Query) (*SearchResult, error)\n```\n\n### 5. 查询优化\n- 合理使用filter vs query\n- 聚合查询优化\n- 分页深度限制\n\n### 项目结构\n```\ncloud/pkg/opensearch/\n├── client.go         # OpenSearch客户端\n├── index.go          # 索引管理\n├── query.go          # 查询构建\n└── bulk.go           # 批量写入\n\ndeploy/kubernetes/opensearch/\n├── opensearch-statefulset.yaml\n├── opensearch-dashboards.yaml\n├── index-templates/\n│   ├── events.json\n│   ├── alerts.json\n│   └── assets.json\n└── ism-policies/\n    └── edr-lifecycle.json\n```\n\n## 验收标准\n- [ ] OpenSearch集群正常运行\n- [ ] 索引模板正确应用\n- [ ] ECS字段映射正确\n- [ ] 批量写入吞吐量 \u003e 5万/秒\n- [ ] 查询延迟 \u003c 100ms (简单查询)\n- [ ] ISM策略正常执行\n- [ ] 监控仪表板可访问",
    "id": "task_1764425253230307000",
    "module": "Cloud",
    "name": "15-OpenSearch事件存储",
    "simhash": 590630191750656900,
    "status": "todo",
    "updated_at": "2025-11-30T11:24:48+08:00"
  },
  {
    "created_at": "2025-11-29T22:07:46+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: 15-OpenSearch事件存储\n- **被依赖任务**: \n  - 16-PostgreSQL配置存储\n  - 19-告警生成与管理服务\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → PostgreSQL\n- **许可证**: PostgreSQL License\n- **ORM**: sqlx (MIT) / GORM (MIT)\n\n## 接口定义\n- **输入**: 业务数据 (用户、资产、策略等)\n- **输出**: \n  - CRUD API\n  - 数据库Schema\n\n## 任务内容\n\n部署和配置PostgreSQL数据库：\n\n### 1. PostgreSQL部署配置\n```yaml\n# deploy/docker/docker-compose.yml\nservices:\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: edr\n      POSTGRES_USER: edr\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n```\n\n### 2. 数据库Schema设计\n```sql\n-- migrations/001_init.sql\n\n-- 租户表\nCREATE TABLE tenants (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- 用户表\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID REFERENCES tenants(id),\n  username VARCHAR(255) NOT NULL UNIQUE,\n  email VARCHAR(255) NOT NULL,\n  password_hash VARCHAR(255) NOT NULL,\n  role VARCHAR(50) NOT NULL,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- 资产表\nCREATE TABLE assets (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID REFERENCES tenants(id),\n  agent_id VARCHAR(255) NOT NULL,\n  hostname VARCHAR(255),\n  os_type VARCHAR(50),\n  os_version VARCHAR(100),\n  ip_addresses JSONB,\n  status VARCHAR(50) DEFAULT 'online',\n  last_seen TIMESTAMP,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- 策略表\nCREATE TABLE policies (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID REFERENCES tenants(id),\n  name VARCHAR(255) NOT NULL,\n  type VARCHAR(50) NOT NULL,\n  content TEXT,\n  version INT DEFAULT 1,\n  status VARCHAR(50) DEFAULT 'enabled',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- 告警表 (元数据)\nCREATE TABLE alerts (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  tenant_id UUID REFERENCES tenants(id),\n  title VARCHAR(500) NOT NULL,\n  severity VARCHAR(50) NOT NULL,\n  status VARCHAR(50) DEFAULT 'open',\n  asset_id UUID REFERENCES assets(id),\n  rule_id UUID,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n### 3. 数据库迁移工具配置\n```go\n// cloud/pkg/database/migrate.go\nimport \"github.com/golang-migrate/migrate/v4\"\n\nfunc RunMigrations(dbURL string) error {\n  m, _ := migrate.New(\n    \"file://migrations\",\n    dbURL,\n  )\n  return m.Up()\n}\n```\n\n### 4. Go数据访问层封装\n```go\n// cloud/pkg/database/db.go\nimport \"github.com/jmoiron/sqlx\"\n\ntype DB struct {\n  *sqlx.DB\n}\n\nfunc NewDB(dsn string) (*DB, error) {\n  db, err := sqlx.Connect(\"postgres\", dsn)\n  if err != nil {\n    return nil, err\n  }\n  db.SetMaxOpenConns(25)\n  db.SetMaxIdleConns(5)\n  return \u0026DB{db}, nil\n}\n```\n\n### 5. Repository模式\n```go\n// cloud/internal/repository/asset.go\ntype AssetRepository struct {\n  db *database.DB\n}\n\nfunc (r *AssetRepository) Create(asset *models.Asset) error {\n  query := `INSERT INTO assets (tenant_id, agent_id, hostname, os_type) \n            VALUES ($1, $2, $3, $4) RETURNING id`\n  return r.db.QueryRowx(query, asset.TenantID, asset.AgentID, asset.Hostname, asset.OSType).\n    Scan(\u0026asset.ID)\n}\n\nfunc (r *AssetRepository) GetByID(id string) (*models.Asset, error) {\n  var asset models.Asset\n  err := r.db.Get(\u0026asset, \"SELECT * FROM assets WHERE id = $1\", id)\n  return \u0026asset, err\n}\n```\n\n### 6. 连接池配置\n```go\ndb.SetMaxOpenConns(25)\ndb.SetMaxIdleConns(5)\ndb.SetConnMaxLifetime(5 * time.Minute)\ndb.SetConnMaxIdleTime(1 * time.Minute)\n```\n\n### 项目结构\n```\ncloud/\n├── migrations/\n│   ├── 001_init.sql\n│   ├── 002_add_indexes.sql\n│   └── ...\n├── pkg/database/\n│   ├── db.go           # 数据库连接\n│   ├── migrate.go      # 迁移工具\n│   └── transaction.go  # 事务管理\n└── internal/repository/\n    ├── tenant.go\n    ├── user.go\n    ├── asset.go\n    ├── policy.go\n    └── alert.go\n```\n\n## 验收标准\n- [ ] 数据库表结构正确创建\n- [ ] 迁移工具正常运行\n- [ ] 能完成CRUD操作\n- [ ] 连接池配置合理\n- [ ] 事务管理正常\n- [ ] 索引优化有效",
    "id": "task_1764425266337506000",
    "module": "Cloud",
    "name": "16-PostgreSQL配置存储",
    "simhash": 590658779052975100,
    "status": "todo",
    "updated_at": "2025-11-30T11:30:34+08:00"
  },
  {
    "created_at": "2025-11-29T22:08:00+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: 14-事件处理管线服务\n- **被依赖任务**: \n  - 18-IOC威胁情报匹配 (规则配合)\n  - 19-告警生成与管理服务 (检测结果)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → Sigma规则格式\n- **规则格式**: Sigma YAML\n- **查询后端**: OpenSearch\n\n## 接口定义\n- **输入**: \n  - Kafka Topic: edr.events.normalized\n  - Sigma规则集 (YAML格式)\n- **输出**: \n  - Kafka Topic: edr.alerts\n  - 告警数据 (JSON)\n\n## 任务内容\n\n实现云端Sigma规则检测引擎：\n\n### 1. Sigma规则加载和解析\n```go\ntype SigmaRule struct {\n  Title       string\n  Description string\n  Level       string\n  Status      string\n  Detection   Detection\n  Tags        []string  // ATT\u0026CK tags\n}\n\nfunc LoadRules(path string) ([]*SigmaRule, error)\n```\n\n### 2. 规则转换为OpenSearch查询\n```go\ntype SigmaBackend interface {\n  Convert(rule *SigmaRule) (*QueryDSL, error)\n}\n\ntype OpenSearchBackend struct{}\n\nfunc (b *OpenSearchBackend) Convert(rule *SigmaRule) (*QueryDSL, error) {\n  // Sigma条件 -\u003e OpenSearch Bool Query\n}\n```\n\n### 3. 实时流式检测\n```go\ntype StreamDetector struct {\n  consumer *kafka.Consumer\n  rules    []*CompiledRule\n}\n\nfunc (d *StreamDetector) Detect(event *Event) []*Alert\n```\n\n### 4. 定时批量检测\n- 历史事件回扫\n- 新规则溯源检测\n- 调度配置\n\n### 5. 规则管理API\n```go\n// POST /api/v1/rules/sigma\n// GET /api/v1/rules/sigma/{id}\n// PUT /api/v1/rules/sigma/{id}\n// DELETE /api/v1/rules/sigma/{id}\n```\n\n### 6. 规则版本控制\n- Git-like版本管理\n- 规则变更历史\n- 回滚能力\n\n### 项目结构\n```\ncloud/internal/detection/sigma/\n├── parser.go         # Sigma规则解析\n├── compiler.go       # 规则编译\n├── backend/\n│   ├── opensearch.go # OpenSearch后端\n│   └── kafka.go      # Kafka流处理\n├── detector.go       # 检测逻辑\n└── api.go            # 规则管理API\n\ncloud/rules/sigma/\n├── windows/          # Windows规则\n├── linux/            # Linux规则\n└── macos/            # macOS规则\n```\n\n## 验收标准\n- [ ] 规则能正确加载\n- [ ] 能检测匹配的事件\n- [ ] 规则更新实时生效\n- [ ] 规则版本可回滚\n- [ ] 检测延迟 \u003c 100ms\n- [ ] 命中统计正确",
    "id": "task_1764425280412331000",
    "module": "Cloud",
    "name": "17-云端Sigma检测引擎",
    "simhash": 590634589797165400,
    "status": "todo",
    "updated_at": "2025-11-30T11:26:44+08:00"
  },
  {
    "created_at": "2025-11-29T22:08:14+08:00",
    "description": "实现IOC威胁情报匹配引擎，包括：\n1. IOC数据模型设计（IP/域名/哈希/URL）\n2. IOC导入接口（CSV/STIX/手动）\n3. Bloom Filter预过滤实现\n4. Redis IOC缓存\n5. 实时IOC匹配（事件流处理）\n6. IOC生命周期管理（有效期、置信度）\n7. 匹配结果告警生成\n\n技术选型：\n- Redis (BSD 3-Clause)\n- go-bloom (MIT) - Bloom Filter\n\n验收标准：\n- 能导入IOC列表\n- 能实时匹配事件中的IOC\n- 匹配性能满足要求（百万级IOC）",
    "id": "task_1764425294722804000",
    "module": "Cloud",
    "name": "18-IOC威胁情报匹配",
    "simhash": 736541982913636700,
    "status": "todo",
    "updated_at": "2025-11-29T22:08:14+08:00"
  },
  {
    "created_at": "2025-11-29T22:08:29+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: \n  - 17-云端Sigma检测引擎\n  - 18-IOC威胁情报匹配\n- **被依赖任务**: \n  - 23-响应编排服务 (触发响应)\n  - 26-告警管理页面 (告警展示)\n  - 36-告警通知服务 (告警推送)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n- **存储**: PostgreSQL (元数据) + OpenSearch (全文检索)\n- **告警格式**: ECS兼容\n\n## 接口定义\n- **输入**: \n  - 检测结果 (Sigma匹配、IOC匹配)\n  - Kafka Topic: detection.results\n- **输出**: \n  - 告警存储 (PostgreSQL + OpenSearch)\n  - Kafka Topic: edr.alerts\n  - 告警API\n\n## 任务内容\n\n实现告警生成和管理服务：\n\n### 1. 告警生成器\n```go\ntype AlertGenerator struct {\n  deduper   *Deduplicator\n  enricher  *Enricher\n  publisher *kafka.Producer\n}\n\nfunc (g *AlertGenerator) Generate(detection *DetectionResult) *Alert {\n  alert := \u0026Alert{\n    ID:        uuid.New(),\n    Title:     detection.RuleName,\n    Severity:  detection.Severity,\n    Status:    AlertStatusOpen,\n    CreatedAt: time.Now(),\n    Source:    detection.Source,  // sigma/ioc/ml\n    Events:    detection.Events,\n    // ...\n  }\n  return alert\n}\n```\n\n### 2. 告警去重和聚合\n```go\ntype Deduplicator struct {\n  window  time.Duration  // 聚合窗口\n  keyFunc func(*Alert) string\n}\n\nfunc (d *Deduplicator) Dedupe(alert *Alert) (*Alert, bool) {\n  key := d.keyFunc(alert)\n  // 检查是否已存在相同告警\n  // 存在则聚合，否则创建新告警\n}\n```\n\n### 3. 告警严重性分级\n```go\ntype SeverityCalculator struct{}\n\nfunc (c *SeverityCalculator) Calculate(alert *Alert) Severity {\n  // 基于规则严重性、IOC置信度、资产重要性等计算\n}\n```\n\n### 4. 告警上下文丰富化\n- 关联资产信息\n- 关联历史告警\n- ATT\u0026CK战术映射\n\n### 5. 告警存储\n```go\n// PostgreSQL: 告警元数据\ntype AlertRepository interface {\n  Create(alert *Alert) error\n  Update(id string, status Status) error\n  GetByID(id string) (*Alert, error)\n}\n\n// OpenSearch: 告警全文检索\ntype AlertIndex interface {\n  Index(alert *Alert) error\n  Search(query SearchQuery) ([]*Alert, error)\n}\n```\n\n### 6. 告警状态流转\n```\nOpen → Investigating → Resolved\n  ↓        ↓\n  → False Positive\n```\n\n### 7. 告警管理API\n```go\n// GET /api/v1/alerts\n// GET /api/v1/alerts/{id}\n// PUT /api/v1/alerts/{id}/status\n// POST /api/v1/alerts/batch/close\n```\n\n### 项目结构\n```\ncloud/internal/alert/\n├── generator.go      # 告警生成\n├── deduper.go        # 去重聚合\n├── enricher.go       # 上下文丰富\n├── severity.go       # 严重性计算\n├── repository.go     # PostgreSQL存储\n├── index.go          # OpenSearch索引\n└── api.go            # 管理API\n```\n\n## 验收标准\n- [ ] 检测命中生成告警\n- [ ] 相同告警能聚合\n- [ ] 告警能正确分级\n- [ ] 告警状态流转正确\n- [ ] API能查询和更新告警\n- [ ] 告警写入延迟 \u003c 100ms",
    "id": "task_1764425309449623000",
    "module": "Cloud",
    "name": "19-告警生成与管理服务",
    "simhash": 17778271063185887000,
    "status": "todo",
    "updated_at": "2025-11-30T11:26:44+08:00"
  },
  {
    "created_at": "2025-11-29T22:08:42+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-E (Sprint 2-4)\n- **依赖任务**: 12-云端事件接收服务\n- **被依赖任务**: \n  - 21-策略管理服务 (资产分组)\n  - 27-终端管理页面 (资产展示)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n- **存储**: PostgreSQL\n\n## 接口定义\n- **输入**: \n  - Agent注册信息\n  - Agent心跳数据\n- **输出**: \n  - 资产API\n  - 资产变更事件\n\n## 任务内容\n\n实现资产发现和管理服务：\n\n### 1. Agent注册时资产自动登记\n```go\ntype AssetService struct {\n  repo *repository.AssetRepository\n}\n\nfunc (s *AssetService) RegisterAgent(req *RegisterRequest) (*Asset, error) {\n  asset := \u0026Asset{\n    ID:          uuid.New(),\n    AgentID:     req.AgentID,\n    TenantID:    req.TenantID,\n    Hostname:    req.Hostname,\n    OSType:      req.OSType,\n    OSVersion:   req.OSVersion,\n    IPAddresses: req.IPAddresses,\n    MACAddresses: req.MACAddresses,\n    Status:      AssetStatusOnline,\n    CreatedAt:   time.Now(),\n  }\n  return s.repo.Create(asset)\n}\n```\n\n### 2. 资产信息采集\n```go\ntype AssetInfo struct {\n  Hostname     string\n  OSType       string   // windows, linux, macos\n  OSVersion    string\n  Architecture string   // x64, arm64\n  IPAddresses  []string\n  MACAddresses []string\n  CPU          CPUInfo\n  Memory       MemoryInfo\n  Disk         []DiskInfo\n  AgentVersion string\n}\n```\n\n### 3. 资产状态监控\n```go\ntype StatusMonitor struct {\n  repo    *repository.AssetRepository\n  timeout time.Duration\n}\n\nfunc (m *StatusMonitor) UpdateStatus() {\n  // 标记超过timeout未心跳的资产为离线\n  m.repo.UpdateOfflineAssets(m.timeout)\n}\n\nfunc (m *StatusMonitor) HandleHeartbeat(agentID string) {\n  m.repo.UpdateLastSeen(agentID, time.Now())\n}\n```\n\n### 4. 资产分组管理\n```go\ntype AssetGroup struct {\n  ID          uuid.UUID\n  TenantID    uuid.UUID\n  Name        string\n  Description string\n  Type        string    // department, location, custom\n  ParentID    *uuid.UUID\n}\n\nfunc (s *AssetService) AssignToGroup(assetID, groupID uuid.UUID) error\nfunc (s *AssetService) GetAssetsByGroup(groupID uuid.UUID) ([]*Asset, error)\n```\n\n### 5. 软件资产清单\n```go\ntype SoftwareInventory struct {\n  AssetID      uuid.UUID\n  Name         string\n  Version      string\n  Publisher    string\n  InstallDate  time.Time\n  InstallPath  string\n}\n\nfunc (s *AssetService) UpdateSoftwareInventory(assetID uuid.UUID, software []SoftwareInventory) error\n```\n\n### 6. 资产变更历史记录\n```go\ntype AssetChangeLog struct {\n  ID        uuid.UUID\n  AssetID   uuid.UUID\n  FieldName string\n  OldValue  string\n  NewValue  string\n  ChangedAt time.Time\n}\n\nfunc (s *AssetService) LogChange(assetID uuid.UUID, field, old, new string) error\n```\n\n### 7. 资产管理API\n```go\n// GET /api/v1/assets\n// GET /api/v1/assets/{id}\n// PUT /api/v1/assets/{id}\n// DELETE /api/v1/assets/{id}\n// GET /api/v1/assets/{id}/software\n// GET /api/v1/assets/{id}/changes\n// GET /api/v1/asset-groups\n// POST /api/v1/asset-groups\n```\n\n### 项目结构\n```\ncloud/internal/asset/\n├── service.go          # 资产服务\n├── repository.go       # 数据存储\n├── monitor.go          # 状态监控\n├── group.go            # 分组管理\n├── software.go         # 软件清单\n├── changelog.go        # 变更历史\n└── api.go              # HTTP API\n```\n\n## 验收标准\n- [ ] Agent上线自动创建资产\n- [ ] 资产信息完整\n- [ ] 离线状态正确标记\n- [ ] 能按分组查询资产\n- [ ] 软件清单正常更新\n- [ ] 变更历史记录完整",
    "id": "task_1764425322817376000",
    "module": "Cloud",
    "name": "20-资产发现与管理服务",
    "simhash": 17292534833583220000,
    "status": "todo",
    "updated_at": "2025-11-30T11:33:26+08:00"
  },
  {
    "created_at": "2025-11-29T22:08:55+08:00",
    "description": "实现策略管理服务，包括：\n1. 策略数据模型（检测策略/响应策略/采集策略）\n2. 策略CRUD API\n3. 策略版本管理\n4. 策略分发机制（全局/分组/终端）\n5. Agent策略同步接口\n6. 策略变更审计日志\n7. 策略灰度发布支持\n\n验收标准：\n- 能创建和编辑策略\n- Agent能同步最新策略\n- 策略版本可回滚\n- 分发范围正确",
    "id": "task_1764425335666332000",
    "module": "Cloud",
    "name": "21-策略管理服务",
    "simhash": 18440541035345994000,
    "status": "todo",
    "updated_at": "2025-11-29T22:08:55+08:00"
  },
  {
    "created_at": "2025-11-29T22:09:09+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-D (Sprint 3-4)\n- **依赖任务**: 02-Agent核心框架开发\n- **被依赖任务**: \n  - 23-响应编排服务 (执行端)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md → C+Go混合架构\n- **响应命令**: Protobuf定义 (proto/edr/commands.proto)\n\n## 接口定义\n- **输入**: \n  - gRPC Command流\n  - 命令类型: KILL_PROCESS, ISOLATE_FILE, QUARANTINE_HOST\n- **输出**: \n  - 执行结果 → gRPC CommandResult\n  - 审计日志\n\n## 任务内容\n\n实现Agent响应执行能力（C+Go）：\n\n### C核心库实现 (agent/core-c/src/response/)\n\n1. **进程终止执行器** - process_killer.c\n```c\n// Windows实现\nint edr_kill_process_win(uint32_t pid, int force) {\n  HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pid);\n  if (hProcess == NULL) return -1;\n  BOOL result = TerminateProcess(hProcess, 1);\n  CloseHandle(hProcess);\n  return result ? 0 : -1;\n}\n\n// Linux实现\nint edr_kill_process_linux(uint32_t pid, int force) {\n  int sig = force ? SIGKILL : SIGTERM;\n  return kill(pid, sig);\n}\n```\n\n2. **进程树终止**\n```c\nint edr_kill_process_tree(uint32_t pid) {\n  // 1. 获取子进程列表\n  // 2. 递归终止子进程\n  // 3. 终止目标进程\n}\n```\n\n3. **文件隔离执行器** - file_isolator.c\n```c\nint edr_isolate_file(const char *path, const char *quarantine_dir) {\n  // 1. 计算文件哈希\n  // 2. 重命名并移动到隔离区\n  // 3. 记录原始路径\n}\n\nint edr_restore_file(const char *hash, const char *original_path) {\n  // 从隔离区恢复文件\n}\n```\n\n4. **文件安全删除**\n```c\nint edr_secure_delete(const char *path) {\n  // 1. 覆写文件内容\n  // 2. 删除文件\n}\n```\n\n### Go业务层 (agent/main-go/internal/response/)\n\n5. **响应命令接收**\n```go\ntype ResponseExecutor struct {\n  grpcClient pb.AgentServiceClient\n  executor   *CExecutor  // CGO调用\n}\n\nfunc (r *ResponseExecutor) HandleCommand(cmd *pb.Command) *pb.CommandResult {\n  switch cmd.Type {\n  case pb.CommandType_KILL_PROCESS:\n    return r.killProcess(cmd.GetKillProcess())\n  case pb.CommandType_ISOLATE_FILE:\n    return r.isolateFile(cmd.GetIsolateFile())\n  // ...\n  }\n}\n```\n\n6. **执行结果上报**\n```go\nfunc (r *ResponseExecutor) ReportResult(result *pb.CommandResult) error {\n  return r.grpcClient.ReportCommandResult(ctx, result)\n}\n```\n\n7. **执行超时和重试**\n```go\nfunc (r *ResponseExecutor) executeWithTimeout(\n  cmd *pb.Command, \n  timeout time.Duration,\n) *pb.CommandResult {\n  ctx, cancel := context.WithTimeout(context.Background(), timeout)\n  defer cancel()\n  // ...\n}\n```\n\n8. **操作审计日志**\n```go\nfunc (r *ResponseExecutor) logAudit(cmd *pb.Command, result *pb.CommandResult) {\n  log.Info(\"response_action\",\n    zap.String(\"command_id\", cmd.Id),\n    zap.String(\"type\", cmd.Type.String()),\n    zap.Bool(\"success\", result.Success),\n  )\n}\n```\n\n### 项目结构\n```\nagent/core-c/src/response/\n├── process_killer.c    # 进程终止\n├── file_isolator.c     # 文件隔离\n├── response.h          # 接口定义\n└── CMakeLists.txt\n\nagent/main-go/internal/response/\n├── executor.go         # 执行器\n├── cgo.go             # CGO封装\n├── audit.go           # 审计日志\n└── executor_test.go\n```\n\n## 验收标准\n- [ ] 能接收云端响应命令\n- [ ] 成功终止指定进程\n- [ ] 进程树终止正确\n- [ ] 成功隔离指定文件\n- [ ] 文件恢复功能正常\n- [ ] 执行结果正确上报\n- [ ] 审计日志记录完整",
    "id": "task_1764425349754738000",
    "module": "Agent",
    "name": "22-Agent响应执行器",
    "simhash": 734741119218950700,
    "status": "todo",
    "updated_at": "2025-11-30T11:29:12+08:00"
  },
  {
    "created_at": "2025-11-29T22:09:22+08:00",
    "description": "实现云端响应编排服务，包括：\n1. 响应动作定义（进程终止/文件隔离/网络阻断）\n2. 响应策略配置（自动响应规则）\n3. 响应命令下发（通过Kafka/gRPC）\n4. 响应结果跟踪\n5. 审批工作流（高风险操作）\n6. 响应历史记录\n7. 响应管理API\n\n验收标准：\n- 能配置自动响应规则\n- 告警触发自动响应\n- 高风险操作需审批\n- 响应结果可追溯",
    "id": "task_1764425362840525000",
    "module": "Cloud",
    "name": "23-响应编排服务",
    "simhash": 17218034933352307000,
    "status": "todo",
    "updated_at": "2025-11-29T22:09:22+08:00"
  },
  {
    "created_at": "2025-11-29T22:09:36+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-F (Sprint 3-5)\n- **依赖任务**: 01-项目基础框架搭建\n- **被依赖任务**: \n  - 25-安全态势仪表板\n  - 26-告警管理页面\n  - 27-终端管理页面\n  - 28-事件检索与威胁狩猎\n  - 29-策略管理页面\n  - 30-用户权限管理页面\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - 框架: React 18 + TypeScript\n  - UI组件: Ant Design 5 (MIT)\n  - 构建工具: Vite (MIT)\n  - 状态管理: **Zustand** (MIT)\n- **许可证**: 全部MIT/Apache 2.0\n\n## 接口定义\n- **输入**: 后端REST API\n- **输出**: Web应用\n\n## 任务内容\n\n搭建管理控制台前端框架：\n\n### 1. 项目初始化\n```bash\npnpm create vite console --template react-ts\ncd console\npnpm add antd @ant-design/icons axios zustand react-router-dom\n```\n\n### 2. 目录结构\n```\nconsole/\n├── src/\n│   ├── api/              # API封装\n│   │   ├── client.ts     # Axios实例\n│   │   └── endpoints/    # 各模块API\n│   ├── components/       # 通用组件\n│   │   ├── Layout/       # 布局组件\n│   │   └── common/       # 公共组件\n│   ├── pages/            # 页面组件\n│   ├── stores/           # Zustand stores\n│   ├── hooks/            # 自定义hooks\n│   ├── utils/            # 工具函数\n│   ├── types/            # TypeScript类型\n│   └── App.tsx\n├── vite.config.ts\n├── tsconfig.json\n└── package.json\n```\n\n### 3. Zustand状态管理\n```typescript\n// stores/authStore.ts\nimport { create } from 'zustand'\n\ninterface AuthState {\n  user: User | null\n  token: string | null\n  login: (credentials: Credentials) =\u003e Promise\u003cvoid\u003e\n  logout: () =\u003e void\n}\n\nexport const useAuthStore = create\u003cAuthState\u003e((set) =\u003e ({\n  user: null,\n  token: null,\n  login: async (credentials) =\u003e {\n    const { user, token } = await api.login(credentials)\n    set({ user, token })\n  },\n  logout: () =\u003e set({ user: null, token: null }),\n}))\n```\n\n### 4. API请求封装\n```typescript\n// api/client.ts\nimport axios from 'axios'\n\nconst client = axios.create({\n  baseURL: import.meta.env.VITE_API_URL,\n})\n\nclient.interceptors.request.use((config) =\u003e {\n  const token = useAuthStore.getState().token\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`\n  }\n  return config\n})\n```\n\n### 5. 路由配置\n```typescript\n// App.tsx\n\u003cRoutes\u003e\n  \u003cRoute path=\"/login\" element={\u003cLogin /\u003e} /\u003e\n  \u003cRoute path=\"/\" element={\u003cLayout /\u003e}\u003e\n    \u003cRoute index element={\u003cDashboard /\u003e} /\u003e\n    \u003cRoute path=\"alerts\" element={\u003cAlerts /\u003e} /\u003e\n    \u003cRoute path=\"endpoints\" element={\u003cEndpoints /\u003e} /\u003e\n    \u003cRoute path=\"events\" element={\u003cEvents /\u003e} /\u003e\n    \u003cRoute path=\"policies\" element={\u003cPolicies /\u003e} /\u003e\n    \u003cRoute path=\"settings\" element={\u003cSettings /\u003e} /\u003e\n  \u003c/Route\u003e\n\u003c/Routes\u003e\n```\n\n### 6. 布局框架\n```typescript\n// components/Layout/index.tsx\nconst Layout: React.FC = () =\u003e (\n  \u003cAntLayout\u003e\n    \u003cSider\u003e\u003cSideMenu /\u003e\u003c/Sider\u003e\n    \u003cAntLayout\u003e\n      \u003cHeader\u003e\u003cTopNav /\u003e\u003c/Header\u003e\n      \u003cContent\u003e\u003cOutlet /\u003e\u003c/Content\u003e\n    \u003c/AntLayout\u003e\n  \u003c/AntLayout\u003e\n)\n```\n\n### 7. 主题配置\n```typescript\n// theme/index.ts\nexport const theme: ThemeConfig = {\n  token: {\n    colorPrimary: '#1890ff',\n    borderRadius: 4,\n  },\n}\n```\n\n## 验收标准\n- [ ] 项目能正常启动 (`pnpm dev`)\n- [ ] Ant Design组件正常渲染\n- [ ] 路由导航正常\n- [ ] Zustand状态管理正常\n- [ ] API调用正常 (Mock或真实后端)\n- [ ] JWT认证流程完整\n- [ ] 布局框架正常",
    "id": "task_1764425376580229000",
    "module": "Console",
    "name": "24-管理控制台前端框架",
    "simhash": 1451333528299939300,
    "status": "todo",
    "updated_at": "2025-11-30T11:28:00+08:00"
  },
  {
    "created_at": "2025-11-29T22:09:51+08:00",
    "description": "实现安全态势仪表板，包括：\n1. 告警概览卡片（按严重性/状态统计）\n2. 终端状态概览（在线/离线/风险分布）\n3. 告警趋势图表（时间序列，ECharts）\n4. Top N分析（进程/IP/域名）\n5. MITRE ATT\u0026CK覆盖度矩阵（ECharts热力图）\n6. **攻击链可视化**（@antv/g6关系图）\n7. 关键指标展示（MTTD/MTTR）\n8. 数据自动刷新\n\n技术选型（与决策项对齐）：\n- ECharts (Apache 2.0) - 图表库\n- Ant Design Charts (MIT) - AntV封装\n- **@antv/g6 (MIT)** - 关系图可视化（攻击链/进程树）\n\n验收标准：\n- 仪表板正常展示\n- 数据实时更新\n- 图表交互正常\n- 攻击链可视化正常",
    "id": "task_1764425391374864000",
    "module": "Console",
    "name": "25-安全态势仪表板",
    "simhash": 9923822616070978000,
    "status": "todo",
    "updated_at": "2025-11-30T00:36:13+08:00"
  },
  {
    "created_at": "2025-11-29T22:10:04+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-F (Sprint 3-5)\n- **依赖任务**: \n  - 24-管理控制台前端框架\n  - 19-告警生成与管理服务\n- **被依赖任务**: 无 (终端页面)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n- **UI组件**: Ant Design 5\n\n## 接口定义\n- **输入**: \n  - GET /api/v1/alerts\n  - GET /api/v1/alerts/{id}\n  - PUT /api/v1/alerts/{id}/status\n  - POST /api/v1/alerts/batch/close\n- **输出**: 告警管理界面\n\n## 任务内容\n\n实现告警管理页面：\n\n### 1. 告警列表\n```typescript\nconst AlertList: React.FC = () =\u003e {\n  const [filters, setFilters] = useState\u003cAlertFilters\u003e({})\n  const { data, isLoading } = useQuery(['alerts', filters], () =\u003e fetchAlerts(filters))\n\n  return (\n    \u003c\u003e\n      \u003cAlertFilters onChange={setFilters} /\u003e\n      \u003cTable\n        dataSource={data?.items}\n        columns={alertColumns}\n        rowSelection={{ onChange: handleSelect }}\n        pagination={{\n          total: data?.total,\n          pageSize: 20,\n        }}\n      /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n### 2. 告警筛选器\n```typescript\nconst AlertFilters: React.FC = ({ onChange }) =\u003e (\n  \u003cForm layout=\"inline\" onValuesChange={(_, values) =\u003e onChange(values)}\u003e\n    \u003cForm.Item name=\"severity\"\u003e\n      \u003cSelect placeholder=\"严重性\"\u003e\n        \u003cOption value=\"critical\"\u003eCritical\u003c/Option\u003e\n        \u003cOption value=\"high\"\u003eHigh\u003c/Option\u003e\n        \u003cOption value=\"medium\"\u003eMedium\u003c/Option\u003e\n        \u003cOption value=\"low\"\u003eLow\u003c/Option\u003e\n      \u003c/Select\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"status\"\u003e\n      \u003cSelect placeholder=\"状态\"\u003e\n        \u003cOption value=\"open\"\u003eOpen\u003c/Option\u003e\n        \u003cOption value=\"investigating\"\u003eInvestigating\u003c/Option\u003e\n        \u003cOption value=\"resolved\"\u003eResolved\u003c/Option\u003e\n      \u003c/Select\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"timeRange\"\u003e\n      \u003cRangePicker /\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"search\"\u003e\n      \u003cInput.Search placeholder=\"搜索告警...\" /\u003e\n    \u003c/Form.Item\u003e\n  \u003c/Form\u003e\n)\n```\n\n### 3. 告警详情抽屉\n```typescript\nconst AlertDetail: React.FC\u003c{ alertId: string }\u003e = ({ alertId }) =\u003e {\n  const { data: alert } = useQuery(['alert', alertId], () =\u003e fetchAlert(alertId))\n\n  return (\n    \u003cDrawer title={alert?.title} width={720} visible\u003e\n      \u003cDescriptions column={2}\u003e\n        \u003cDescriptions.Item label=\"严重性\"\u003e\n          \u003cTag color={severityColor[alert?.severity]}\u003e{alert?.severity}\u003c/Tag\u003e\n        \u003c/Descriptions.Item\u003e\n        \u003cDescriptions.Item label=\"状态\"\u003e{alert?.status}\u003c/Descriptions.Item\u003e\n        \u003cDescriptions.Item label=\"终端\"\u003e{alert?.asset?.hostname}\u003c/Descriptions.Item\u003e\n        \u003cDescriptions.Item label=\"时间\"\u003e{alert?.createdAt}\u003c/Descriptions.Item\u003e\n      \u003c/Descriptions\u003e\n      \u003cDivider /\u003e\n      \u003ch4\u003e关联事件\u003c/h4\u003e\n      \u003cEventList events={alert?.events} /\u003e\n    \u003c/Drawer\u003e\n  )\n}\n```\n\n### 4. 关联事件展示\n```typescript\nconst EventList: React.FC\u003c{ events: Event[] }\u003e = ({ events }) =\u003e (\n  \u003cTimeline\u003e\n    {events.map(event =\u003e (\n      \u003cTimeline.Item key={event.id}\u003e\n        \u003cp\u003e\u003cstrong\u003e{event.type}\u003c/strong\u003e - {event.timestamp}\u003c/p\u003e\n        \u003cpre\u003e{JSON.stringify(event.data, null, 2)}\u003c/pre\u003e\n      \u003c/Timeline.Item\u003e\n    ))}\n  \u003c/Timeline\u003e\n)\n```\n\n### 5. 告警处置操作\n```typescript\nconst AlertActions: React.FC\u003c{ alert: Alert }\u003e = ({ alert }) =\u003e {\n  const updateStatus = useMutation(updateAlertStatus)\n\n  return (\n    \u003cSpace\u003e\n      \u003cButton onClick={() =\u003e updateStatus.mutate({ id: alert.id, status: 'investigating' })}\u003e\n        开始调查\n      \u003c/Button\u003e\n      \u003cButton onClick={() =\u003e updateStatus.mutate({ id: alert.id, status: 'resolved' })}\u003e\n        关闭告警\n      \u003c/Button\u003e\n      \u003cPopconfirm title=\"标记为误报?\" onConfirm={() =\u003e markFalsePositive(alert.id)}\u003e\n        \u003cButton\u003e误报\u003c/Button\u003e\n      \u003c/Popconfirm\u003e\n    \u003c/Space\u003e\n  )\n}\n```\n\n### 6. 批量操作\n```typescript\nconst BatchActions: React.FC\u003c{ selectedIds: string[] }\u003e = ({ selectedIds }) =\u003e (\n  \u003cSpace\u003e\n    \u003cButton onClick={() =\u003e batchClose(selectedIds)}\u003e批量关闭\u003c/Button\u003e\n    \u003cButton onClick={() =\u003e batchAssign(selectedIds)}\u003e批量分配\u003c/Button\u003e\n  \u003c/Space\u003e\n)\n```\n\n### 7. 处置意见记录\n```typescript\nconst ResolutionForm: React.FC\u003c{ alertId: string }\u003e = ({ alertId }) =\u003e (\n  \u003cForm onFinish={(values) =\u003e addResolution(alertId, values)}\u003e\n    \u003cForm.Item name=\"resolution\" label=\"处置意见\"\u003e\n      \u003cTextArea rows={4} /\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"rootCause\" label=\"根因分析\"\u003e\n      \u003cTextArea rows={2} /\u003e\n    \u003c/Form.Item\u003e\n    \u003cButton type=\"primary\" htmlType=\"submit\"\u003e提交\u003c/Button\u003e\n  \u003c/Form\u003e\n)\n```\n\n### 项目结构\n```\nconsole/src/pages/Alerts/\n├── index.tsx           # 告警列表页\n├── AlertFilters.tsx    # 筛选器\n├── AlertDetail.tsx     # 详情抽屉\n├── EventList.tsx       # 关联事件\n├── AlertActions.tsx    # 操作按钮\n├── BatchActions.tsx    # 批量操作\n├── ResolutionForm.tsx  # 处置表单\n└── styles.less\n```\n\n## 验收标准\n- [ ] 告警列表正常展示\n- [ ] 筛选和搜索功能正常\n- [ ] 详情抽屉正常展示\n- [ ] 状态更新实时生效\n- [ ] 批量操作功能正常\n- [ ] 处置意见记录完整",
    "id": "task_1764425404071634000",
    "module": "Console",
    "name": "26-告警管理页面",
    "simhash": 17200310029513495000,
    "status": "todo",
    "updated_at": "2025-11-30T11:32:04+08:00"
  },
  {
    "created_at": "2025-11-29T22:10:20+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-F (Sprint 3-5)\n- **依赖任务**: \n  - 24-管理控制台前端框架\n  - 20-资产发现与管理服务\n- **被依赖任务**: 无 (终端页面)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n- **UI组件**: Ant Design 5\n\n## 接口定义\n- **输入**: \n  - GET /api/v1/assets\n  - GET /api/v1/assets/{id}\n  - GET /api/v1/assets/{id}/events\n  - POST /api/v1/assets/{id}/actions/{action}\n- **输出**: 终端管理界面\n\n## 任务内容\n\n实现终端管理页面：\n\n### 1. 终端列表\n```typescript\nconst EndpointList: React.FC = () =\u003e {\n  const { data, isLoading } = useQuery(['endpoints'], fetchEndpoints)\n\n  return (\n    \u003cTable\n      dataSource={data}\n      columns={[\n        { title: '主机名', dataIndex: 'hostname' },\n        { title: 'IP地址', dataIndex: 'ipAddress' },\n        { title: '操作系统', dataIndex: 'osType' },\n        { title: '状态', dataIndex: 'status', render: renderStatus },\n        { title: 'Agent版本', dataIndex: 'agentVersion' },\n        { title: '最后上线', dataIndex: 'lastSeen', render: renderTime },\n        { title: '操作', render: (_, record) =\u003e \u003cEndpointActions endpoint={record} /\u003e }\n      ]}\n    /\u003e\n  )\n}\n```\n\n### 2. 终端详情页面\n```typescript\nconst EndpointDetail: React.FC = () =\u003e {\n  const { id } = useParams()\n  const { data: endpoint } = useQuery(['endpoint', id], () =\u003e fetchEndpoint(id))\n\n  return (\n    \u003cPageContainer\u003e\n      \u003cCard title=\"基本信息\"\u003e\n        \u003cDescriptions\u003e\n          \u003cDescriptions.Item label=\"主机名\"\u003e{endpoint?.hostname}\u003c/Descriptions.Item\u003e\n          \u003cDescriptions.Item label=\"操作系统\"\u003e{endpoint?.osType} {endpoint?.osVersion}\u003c/Descriptions.Item\u003e\n          \u003cDescriptions.Item label=\"IP地址\"\u003e{endpoint?.ipAddresses?.join(', ')}\u003c/Descriptions.Item\u003e\n          \u003cDescriptions.Item label=\"MAC地址\"\u003e{endpoint?.macAddresses?.join(', ')}\u003c/Descriptions.Item\u003e\n        \u003c/Descriptions\u003e\n      \u003c/Card\u003e\n      \n      \u003cCard title=\"硬件信息\"\u003e\n        \u003cDescriptions\u003e\n          \u003cDescriptions.Item label=\"CPU\"\u003e{endpoint?.cpu}\u003c/Descriptions.Item\u003e\n          \u003cDescriptions.Item label=\"内存\"\u003e{endpoint?.memory}\u003c/Descriptions.Item\u003e\n          \u003cDescriptions.Item label=\"磁盘\"\u003e{endpoint?.disk}\u003c/Descriptions.Item\u003e\n        \u003c/Descriptions\u003e\n      \u003c/Card\u003e\n    \u003c/PageContainer\u003e\n  )\n}\n```\n\n### 3. 软件清单展示\n```typescript\nconst SoftwareInventory: React.FC\u003c{ endpointId: string }\u003e = ({ endpointId }) =\u003e {\n  const { data } = useQuery(['software', endpointId], () =\u003e fetchSoftware(endpointId))\n\n  return (\n    \u003cTable\n      dataSource={data}\n      columns={[\n        { title: '软件名称', dataIndex: 'name' },\n        { title: '版本', dataIndex: 'version' },\n        { title: '发布者', dataIndex: 'publisher' },\n        { title: '安装日期', dataIndex: 'installDate' },\n      ]}\n    /\u003e\n  )\n}\n```\n\n### 4. 告警历史\n```typescript\nconst AlertHistory: React.FC\u003c{ endpointId: string }\u003e = ({ endpointId }) =\u003e {\n  const { data } = useQuery(['endpointAlerts', endpointId], () =\u003e fetchEndpointAlerts(endpointId))\n\n  return (\n    \u003cList\n      dataSource={data}\n      renderItem={alert =\u003e (\n        \u003cList.Item\u003e\n          \u003cList.Item.Meta\n            title={\u003cLink to={`/alerts/${alert.id}`}\u003e{alert.title}\u003c/Link\u003e}\n            description={`${alert.severity} - ${alert.createdAt}`}\n          /\u003e\n        \u003c/List.Item\u003e\n      )}\n    /\u003e\n  )\n}\n```\n\n### 5. 事件时间线\n```typescript\nconst EventTimeline: React.FC\u003c{ endpointId: string }\u003e = ({ endpointId }) =\u003e {\n  const { data } = useQuery(['endpointEvents', endpointId], () =\u003e fetchEndpointEvents(endpointId))\n\n  return (\n    \u003cTimeline mode=\"left\"\u003e\n      {data?.map(event =\u003e (\n        \u003cTimeline.Item \n          key={event.id}\n          label={event.timestamp}\n          color={eventColor[event.type]}\n        \u003e\n          \u003cp\u003e\u003cstrong\u003e{event.type}\u003c/strong\u003e\u003c/p\u003e\n          \u003cp\u003e{event.summary}\u003c/p\u003e\n        \u003c/Timeline.Item\u003e\n      ))}\n    \u003c/Timeline\u003e\n  )\n}\n```\n\n### 6. 终端操作\n```typescript\nconst EndpointActions: React.FC\u003c{ endpoint: Endpoint }\u003e = ({ endpoint }) =\u003e {\n  const executeAction = useMutation(executeEndpointAction)\n\n  return (\n    \u003cDropdown menu={{\n      items: [\n        { key: 'scan', label: '立即扫描', onClick: () =\u003e executeAction.mutate({ id: endpoint.id, action: 'scan' }) },\n        { key: 'isolate', label: '网络隔离', onClick: () =\u003e executeAction.mutate({ id: endpoint.id, action: 'isolate' }) },\n        { key: 'upgrade', label: '升级Agent', onClick: () =\u003e executeAction.mutate({ id: endpoint.id, action: 'upgrade' }) },\n      ]\n    }}\u003e\n      \u003cButton\u003e操作 \u003cDownOutlined /\u003e\u003c/Button\u003e\n    \u003c/Dropdown\u003e\n  )\n}\n```\n\n### 7. Agent状态监控\n```typescript\nconst AgentStatus: React.FC\u003c{ endpoint: Endpoint }\u003e = ({ endpoint }) =\u003e (\n  \u003cCard\u003e\n    \u003cStatistic \n      title=\"Agent状态\" \n      value={endpoint.status}\n      prefix={\u003cBadge status={endpoint.status === 'online' ? 'success' : 'error'} /\u003e}\n    /\u003e\n    \u003cStatistic title=\"CPU使用率\" value={endpoint.cpuUsage} suffix=\"%\" /\u003e\n    \u003cStatistic title=\"内存使用率\" value={endpoint.memoryUsage} suffix=\"%\" /\u003e\n  \u003c/Card\u003e\n)\n```\n\n### 项目结构\n```\nconsole/src/pages/Endpoints/\n├── index.tsx           # 终端列表\n├── EndpointDetail.tsx  # 终端详情\n├── SoftwareInventory.tsx # 软件清单\n├── AlertHistory.tsx    # 告警历史\n├── EventTimeline.tsx   # 事件时间线\n├── EndpointActions.tsx # 操作菜单\n├── AgentStatus.tsx     # Agent状态\n└── styles.less\n```\n\n## 验收标准\n- [ ] 终端列表正常展示\n- [ ] 筛选和搜索功能正常\n- [ ] 详情信息完整\n- [ ] 软件清单正常展示\n- [ ] 操作功能正常执行\n- [ ] Agent状态实时更新",
    "id": "task_1764425420591620000",
    "module": "Console",
    "name": "27-终端管理页面",
    "simhash": 17652939523244415000,
    "status": "todo",
    "updated_at": "2025-11-30T11:32:04+08:00"
  },
  {
    "created_at": "2025-11-29T22:10:33+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-F (Sprint 3-5)\n- **依赖任务**: \n  - 24-管理控制台前端框架\n  - 15-OpenSearch事件存储\n- **被依赖任务**: 无 (终端页面)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n- **事件格式**: ECS (Elastic Common Schema)\n- **UI组件**: Ant Design 5\n\n## 接口定义\n- **输入**: \n  - POST /api/v1/events/search\n  - GET /api/v1/hunt/templates\n  - POST /api/v1/hunt/templates\n- **输出**: 事件检索与威胁狩猎界面\n\n## 任务内容\n\n实现事件检索和威胁狩猎界面：\n\n### 1. 事件检索页面\n```typescript\nconst EventSearch: React.FC = () =\u003e {\n  const [query, setQuery] = useState\u003cSearchQuery\u003e({})\n  const { data, isLoading, refetch } = useQuery(\n    ['events', query], \n    () =\u003e searchEvents(query),\n    { enabled: false }\n  )\n\n  return (\n    \u003cPageContainer\u003e\n      \u003cQueryBuilder onChange={setQuery} onSearch={refetch} /\u003e\n      \u003cDivider /\u003e\n      \u003cEventResults data={data} loading={isLoading} /\u003e\n    \u003c/PageContainer\u003e\n  )\n}\n```\n\n### 2. 查询构建器\n```typescript\nconst QueryBuilder: React.FC = ({ onChange, onSearch }) =\u003e {\n  const [conditions, setConditions] = useState\u003cCondition[]\u003e([])\n\n  return (\n    \u003cCard\u003e\n      \u003cForm layout=\"vertical\"\u003e\n        \u003cForm.Item label=\"时间范围\"\u003e\n          \u003cRangePicker showTime onChange={(dates) =\u003e onChange({ timeRange: dates })} /\u003e\n        \u003c/Form.Item\u003e\n        \n        \u003cForm.Item label=\"查询条件\"\u003e\n          {conditions.map((cond, idx) =\u003e (\n            \u003cSpace key={idx} style={{ marginBottom: 8 }}\u003e\n              \u003cSelect value={cond.field} onChange={(v) =\u003e updateCondition(idx, 'field', v)}\u003e\n                \u003cOption value=\"process.name\"\u003e进程名\u003c/Option\u003e\n                \u003cOption value=\"process.executable\"\u003e可执行文件路径\u003c/Option\u003e\n                \u003cOption value=\"network.destination.ip\"\u003e目标IP\u003c/Option\u003e\n                \u003cOption value=\"file.path\"\u003e文件路径\u003c/Option\u003e\n                \u003cOption value=\"user.name\"\u003e用户名\u003c/Option\u003e\n              \u003c/Select\u003e\n              \u003cSelect value={cond.operator}\u003e\n                \u003cOption value=\"eq\"\u003e等于\u003c/Option\u003e\n                \u003cOption value=\"contains\"\u003e包含\u003c/Option\u003e\n                \u003cOption value=\"regex\"\u003e正则\u003c/Option\u003e\n                \u003cOption value=\"exists\"\u003e存在\u003c/Option\u003e\n              \u003c/Select\u003e\n              \u003cInput value={cond.value} onChange={(e) =\u003e updateCondition(idx, 'value', e.target.value)} /\u003e\n              \u003cButton icon={\u003cDeleteOutlined /\u003e} onClick={() =\u003e removeCondition(idx)} /\u003e\n            \u003c/Space\u003e\n          ))}\n          \u003cButton icon={\u003cPlusOutlined /\u003e} onClick={addCondition}\u003e添加条件\u003c/Button\u003e\n        \u003c/Form.Item\u003e\n        \n        \u003cButton type=\"primary\" onClick={onSearch}\u003e搜索\u003c/Button\u003e\n      \u003c/Form\u003e\n    \u003c/Card\u003e\n  )\n}\n```\n\n### 3. 时间范围选择\n```typescript\nconst TimeRangePicker: React.FC = ({ onChange }) =\u003e (\n  \u003cSpace\u003e\n    \u003cRadio.Group defaultValue=\"1h\" onChange={(e) =\u003e onChange(e.target.value)}\u003e\n      \u003cRadio.Button value=\"15m\"\u003e15分钟\u003c/Radio.Button\u003e\n      \u003cRadio.Button value=\"1h\"\u003e1小时\u003c/Radio.Button\u003e\n      \u003cRadio.Button value=\"24h\"\u003e24小时\u003c/Radio.Button\u003e\n      \u003cRadio.Button value=\"7d\"\u003e7天\u003c/Radio.Button\u003e\n      \u003cRadio.Button value=\"custom\"\u003e自定义\u003c/Radio.Button\u003e\n    \u003c/Radio.Group\u003e\n  \u003c/Space\u003e\n)\n```\n\n### 4. 查询结果表格\n```typescript\nconst EventResults: React.FC\u003c{ data: SearchResult }\u003e = ({ data }) =\u003e (\n  \u003cTable\n    dataSource={data?.hits}\n    columns={[\n      { title: '时间', dataIndex: '@timestamp', render: formatTime },\n      { title: '类型', dataIndex: 'event.category' },\n      { title: '终端', dataIndex: 'host.hostname' },\n      { title: '进程', dataIndex: 'process.name' },\n      { title: '用户', dataIndex: 'user.name' },\n      { title: '详情', render: (_, record) =\u003e \u003cEventDetail event={record} /\u003e }\n    ]}\n    expandable={{\n      expandedRowRender: (record) =\u003e \u003cpre\u003e{JSON.stringify(record, null, 2)}\u003c/pre\u003e\n    }}\n  /\u003e\n)\n```\n\n### 5. 查询模板保存和复用\n```typescript\nconst QueryTemplates: React.FC = () =\u003e {\n  const { data: templates } = useQuery(['huntTemplates'], fetchTemplates)\n\n  return (\n    \u003cCard title=\"查询模板\"\u003e\n      \u003cList\n        dataSource={templates}\n        renderItem={template =\u003e (\n          \u003cList.Item \n            actions={[\n              \u003cButton onClick={() =\u003e loadTemplate(template)}\u003e加载\u003c/Button\u003e,\n              \u003cButton onClick={() =\u003e deleteTemplate(template.id)}\u003e删除\u003c/Button\u003e\n            ]}\n          \u003e\n            \u003cList.Item.Meta\n              title={template.name}\n              description={template.description}\n            /\u003e\n          \u003c/List.Item\u003e\n        )}\n      /\u003e\n    \u003c/Card\u003e\n  )\n}\n```\n\n### 6. 结果导出\n```typescript\nconst ExportButton: React.FC\u003c{ query: SearchQuery }\u003e = ({ query }) =\u003e (\n  \u003cDropdown menu={{\n    items: [\n      { key: 'csv', label: '导出CSV', onClick: () =\u003e exportToCSV(query) },\n      { key: 'json', label: '导出JSON', onClick: () =\u003e exportToJSON(query) },\n    ]\n  }}\u003e\n    \u003cButton icon={\u003cExportOutlined /\u003e}\u003e导出\u003c/Button\u003e\n  \u003c/Dropdown\u003e\n)\n```\n\n### 7. 事件详情查看\n```typescript\nconst EventDetail: React.FC\u003c{ event: Event }\u003e = ({ event }) =\u003e (\n  \u003cDrawer title=\"事件详情\" width={600}\u003e\n    \u003cDescriptions column={1}\u003e\n      \u003cDescriptions.Item label=\"时间\"\u003e{event['@timestamp']}\u003c/Descriptions.Item\u003e\n      \u003cDescriptions.Item label=\"类型\"\u003e{event.event?.category}\u003c/Descriptions.Item\u003e\n      \u003cDescriptions.Item label=\"终端\"\u003e{event.host?.hostname}\u003c/Descriptions.Item\u003e\n    \u003c/Descriptions\u003e\n    \u003cDivider /\u003e\n    \u003ch4\u003e原始数据\u003c/h4\u003e\n    \u003cpre style={{ background: '#f5f5f5', padding: 16 }}\u003e\n      {JSON.stringify(event, null, 2)}\n    \u003c/pre\u003e\n  \u003c/Drawer\u003e\n)\n```\n\n### 项目结构\n```\nconsole/src/pages/Hunt/\n├── index.tsx           # 主页面\n├── QueryBuilder.tsx    # 查询构建器\n├── TimeRangePicker.tsx # 时间选择\n├── EventResults.tsx    # 结果表格\n├── QueryTemplates.tsx  # 模板管理\n├── ExportButton.tsx    # 导出功能\n├── EventDetail.tsx     # 事件详情\n└── styles.less\n```\n\n## 验收标准\n- [ ] 能执行事件查询\n- [ ] 查询构建器功能完整\n- [ ] 查询结果正确展示\n- [ ] 能保存和复用查询模板\n- [ ] 导出CSV/JSON正常\n- [ ] 事件详情展示完整",
    "id": "task_1764425433665840000",
    "module": "Console",
    "name": "28-事件检索与威胁狩猎",
    "simhash": 7673314923470899000,
    "status": "todo",
    "updated_at": "2025-11-30T11:32:04+08:00"
  },
  {
    "created_at": "2025-11-29T22:10:45+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-F (Sprint 3-5)\n- **依赖任务**: \n  - 24-管理控制台前端框架\n  - 21-策略管理服务\n- **被依赖任务**: 无 (终端页面)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - 代码编辑器: **Monaco Editor** (MIT) - VSCode同款\n  - UI组件: Ant Design 5\n- **规则格式**: YARA规则语法, Sigma YAML, STIX 2.1\n\n## 接口定义\n- **输入**: \n  - GET /api/v1/policies\n  - GET /api/v1/policies/{id}\n  - POST /api/v1/policies\n  - PUT /api/v1/policies/{id}\n  - DELETE /api/v1/policies/{id}\n- **输出**: 策略管理界面\n\n## 任务内容\n\n实现策略管理页面：\n\n### 1. 策略列表页面\n```typescript\nconst PolicyList: React.FC = () =\u003e {\n  const { data, isLoading } = useQuery(['policies'], fetchPolicies)\n  \n  return (\n    \u003cTable\n      dataSource={data}\n      columns={[\n        { title: '策略名称', dataIndex: 'name' },\n        { title: '类型', dataIndex: 'type', render: renderPolicyType },\n        { title: '状态', dataIndex: 'status', render: renderStatus },\n        { title: '版本', dataIndex: 'version' },\n        { title: '更新时间', dataIndex: 'updatedAt' },\n        { title: '操作', render: (_, record) =\u003e \u003cPolicyActions policy={record} /\u003e }\n      ]}\n    /\u003e\n  )\n}\n```\n\n### 2. 策略创建/编辑表单\n```typescript\nconst PolicyForm: React.FC = ({ policy }) =\u003e (\n  \u003cForm initialValues={policy} onFinish={handleSubmit}\u003e\n    \u003cForm.Item name=\"name\" label=\"策略名称\" rules={[{ required: true }]}\u003e\n      \u003cInput /\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"type\" label=\"策略类型\" rules={[{ required: true }]}\u003e\n      \u003cSelect\u003e\n        \u003cOption value=\"sigma\"\u003eSigma规则\u003c/Option\u003e\n        \u003cOption value=\"yara\"\u003eYARA规则\u003c/Option\u003e\n        \u003cOption value=\"ioc\"\u003eIOC列表\u003c/Option\u003e\n        \u003cOption value=\"collection\"\u003e采集策略\u003c/Option\u003e\n        \u003cOption value=\"response\"\u003e响应策略\u003c/Option\u003e\n      \u003c/Select\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"content\" label=\"规则内容\"\u003e\n      \u003cRuleEditor type={policyType} /\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"distribution\" label=\"分发范围\"\u003e\n      \u003cDistributionConfig /\u003e\n    \u003c/Form.Item\u003e\n  \u003c/Form\u003e\n)\n```\n\n### 3. Monaco Editor集成\n```typescript\nimport Editor, { loader } from '@monaco-editor/react'\nimport * as monaco from 'monaco-editor'\n\n// 自定义YARA语言\nconst yaraLanguage: monaco.languages.IMonarchLanguage = {\n  tokenizer: {\n    root: [\n      [/\\b(rule|meta|strings|condition|include|import)\\b/, 'keyword'],\n      [/\\$[a-zA-Z_]\\w*/, 'variable'],\n      [/\"[^\"]*\"/, 'string'],\n      [/\\/\\*.*\\*\\//, 'comment'],\n      [/\\/\\/.*$/, 'comment'],\n    ]\n  }\n}\n\nconst RuleEditor: React.FC\u003c{ type: string; value: string; onChange: (v: string) =\u003e void }\u003e = ({\n  type, value, onChange\n}) =\u003e {\n  const language = type === 'yara' ? 'yara' : type === 'sigma' ? 'yaml' : 'json'\n  \n  return (\n    \u003cEditor\n      height=\"400px\"\n      language={language}\n      value={value}\n      onChange={onChange}\n      options={{\n        minimap: { enabled: false },\n        lineNumbers: 'on',\n        automaticLayout: true,\n        tabSize: 2,\n      }}\n    /\u003e\n  )\n}\n```\n\n### 4. Sigma规则编辑器\n```typescript\nconst SigmaEditor: React.FC = ({ value, onChange }) =\u003e {\n  const [errors, setErrors] = useState\u003cstring[]\u003e([])\n  \n  const validateSigma = (content: string) =\u003e {\n    try {\n      const rule = yaml.parse(content)\n      if (!rule.title) setErrors(['缺少title字段'])\n      if (!rule.detection) setErrors(['缺少detection字段'])\n      else setErrors([])\n    } catch (e) {\n      setErrors([e.message])\n    }\n  }\n  \n  return (\n    \u003c\u003e\n      \u003cEditor\n        language=\"yaml\"\n        value={value}\n        onChange={(v) =\u003e { onChange(v); validateSigma(v); }}\n      /\u003e\n      {errors.map(err =\u003e \u003cAlert type=\"error\" message={err} /\u003e)}\n    \u003c/\u003e\n  )\n}\n```\n\n### 5. IOC列表管理\n```typescript\nconst IOCManager: React.FC = () =\u003e {\n  const [iocs, setIOCs] = useState\u003cIOC[]\u003e([])\n  \n  const handleUpload = async (file: File) =\u003e {\n    const content = await file.text()\n    if (file.name.endsWith('.csv')) {\n      setIOCs(parseCSV(content))\n    } else if (file.name.endsWith('.json')) {\n      const stix = JSON.parse(content)\n      setIOCs(parseSTIX(stix))\n    }\n  }\n  \n  return (\n    \u003c\u003e\n      \u003cUpload accept=\".csv,.json,.stix\" onChange={e =\u003e handleUpload(e.file)}\u003e\n        \u003cButton icon={\u003cUploadOutlined /\u003e}\u003e导入IOC\u003c/Button\u003e\n      \u003c/Upload\u003e\n      \u003cTable \n        dataSource={iocs}\n        columns={[\n          { title: '类型', dataIndex: 'type', render: t =\u003e \u003cTag\u003e{t}\u003c/Tag\u003e },\n          { title: '值', dataIndex: 'value' },\n          { title: '来源', dataIndex: 'source' },\n          { title: '置信度', dataIndex: 'confidence', render: c =\u003e \u003cProgress percent={c} size=\"small\" /\u003e },\n          { title: '有效期', dataIndex: 'validUntil' },\n        ]}\n      /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n### 6. 策略分发配置\n```typescript\nconst DistributionConfig: React.FC = ({ value, onChange }) =\u003e {\n  const [scope, setScope] = useState\u003c'all' | 'group' | 'endpoint'\u003e('all')\n  const { data: groups } = useQuery(['assetGroups'], fetchAssetGroups)\n  const { data: endpoints } = useQuery(['assets'], fetchAssets)\n  \n  return (\n    \u003cCard title=\"分发范围\"\u003e\n      \u003cRadio.Group value={scope} onChange={e =\u003e setScope(e.target.value)}\u003e\n        \u003cRadio value=\"all\"\u003e全部终端\u003c/Radio\u003e\n        \u003cRadio value=\"group\"\u003e按分组\u003c/Radio\u003e\n        \u003cRadio value=\"endpoint\"\u003e指定终端\u003c/Radio\u003e\n      \u003c/Radio.Group\u003e\n      \n      {scope === 'group' \u0026\u0026 (\n        \u003cSelect mode=\"multiple\" placeholder=\"选择分组\" onChange={v =\u003e onChange({ scope, targets: v })}\u003e\n          {groups?.map(g =\u003e \u003cOption key={g.id} value={g.id}\u003e{g.name}\u003c/Option\u003e)}\n        \u003c/Select\u003e\n      )}\n      \n      {scope === 'endpoint' \u0026\u0026 (\n        \u003cTransfer\n          dataSource={endpoints}\n          targetKeys={value?.targets || []}\n          onChange={keys =\u003e onChange({ scope, targets: keys })}\n          render={item =\u003e item.hostname}\n        /\u003e\n      )}\n    \u003c/Card\u003e\n  )\n}\n```\n\n### 7. 策略版本历史\n```typescript\nconst VersionHistory: React.FC\u003c{ policyId: string }\u003e = ({ policyId }) =\u003e {\n  const { data: versions } = useQuery(['policyVersions', policyId], () =\u003e fetchPolicyVersions(policyId))\n  const rollbackMutation = useMutation(rollbackPolicy)\n  \n  return (\n    \u003cTimeline\u003e\n      {versions?.map(v =\u003e (\n        \u003cTimeline.Item key={v.version}\u003e\n          \u003cSpace\u003e\n            \u003cText strong\u003ev{v.version}\u003c/Text\u003e\n            \u003cText type=\"secondary\"\u003e{v.updatedAt}\u003c/Text\u003e\n            \u003cText type=\"secondary\"\u003eby {v.updatedBy}\u003c/Text\u003e\n            {v.version !== versions[0].version \u0026\u0026 (\n              \u003cButton size=\"small\" onClick={() =\u003e rollbackMutation.mutate({ policyId, version: v.version })}\u003e\n                回滚\n              \u003c/Button\u003e\n            )}\n          \u003c/Space\u003e\n          \u003cParagraph ellipsis={{ rows: 2 }}\u003e{v.changeLog}\u003c/Paragraph\u003e\n        \u003c/Timeline.Item\u003e\n      ))}\n    \u003c/Timeline\u003e\n  )\n}\n```\n\n### 项目结构\n```\nconsole/src/pages/Policies/\n├── index.tsx           # 策略列表\n├── PolicyForm.tsx      # 策略表单\n├── editors/\n│   ├── RuleEditor.tsx  # Monaco编辑器封装\n│   ├── YaraEditor.tsx  # YARA专用\n│   ├── SigmaEditor.tsx # Sigma专用\n│   └── IOCManager.tsx  # IOC管理\n├── DistributionConfig.tsx  # 分发配置\n├── VersionHistory.tsx      # 版本历史\n└── styles.less\n```\n\n## 验收标准\n- [ ] 策略CRUD功能正常\n- [ ] Monaco Editor正常加载\n- [ ] YARA/Sigma语法高亮正常\n- [ ] IOC导入 (CSV/STIX) 正常\n- [ ] 策略分发配置正确\n- [ ] 版本历史可查看和回滚\n- [ ] 策略验证功能有效",
    "id": "task_1764425445780552000",
    "module": "Console",
    "name": "29-策略管理页面",
    "simhash": 18420802572575564000,
    "status": "todo",
    "updated_at": "2025-11-30T11:46:36+08:00"
  },
  {
    "created_at": "2025-11-29T22:10:57+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-F (Sprint 3-5)\n- **依赖任务**: \n  - 24-管理控制台前端框架\n  - 35-RBAC权限控制系统\n- **被依赖任务**: 无 (终端页面)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n- **UI组件**: Ant Design 5\n\n## 接口定义\n- **输入**: \n  - GET /api/v1/users\n  - POST /api/v1/users\n  - GET /api/v1/roles\n  - POST /api/v1/audit-logs\n- **输出**: 用户权限管理界面\n\n## 任务内容\n\n实现用户和权限管理：\n\n### 1. 用户管理页面\n```typescript\nconst UserManagement: React.FC = () =\u003e {\n  const { data: users } = useQuery(['users'], fetchUsers)\n\n  return (\n    \u003cPageContainer\u003e\n      \u003cButton type=\"primary\" onClick={() =\u003e setShowCreate(true)}\u003e\n        \u003cPlusOutlined /\u003e 添加用户\n      \u003c/Button\u003e\n      \u003cTable\n        dataSource={users}\n        columns={[\n          { title: '用户名', dataIndex: 'username' },\n          { title: '邮箱', dataIndex: 'email' },\n          { title: '角色', dataIndex: 'role', render: (role) =\u003e \u003cTag\u003e{role}\u003c/Tag\u003e },\n          { title: '状态', dataIndex: 'status', render: renderStatus },\n          { title: '最后登录', dataIndex: 'lastLogin' },\n          { title: '操作', render: (_, record) =\u003e \u003cUserActions user={record} /\u003e }\n        ]}\n      /\u003e\n    \u003c/PageContainer\u003e\n  )\n}\n```\n\n### 2. 用户创建/编辑表单\n```typescript\nconst UserForm: React.FC = ({ user, onSubmit }) =\u003e (\n  \u003cForm initialValues={user} onFinish={onSubmit}\u003e\n    \u003cForm.Item name=\"username\" label=\"用户名\" rules={[{ required: true }]}\u003e\n      \u003cInput /\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"email\" label=\"邮箱\" rules={[{ required: true, type: 'email' }]}\u003e\n      \u003cInput /\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"role\" label=\"角色\" rules={[{ required: true }]}\u003e\n      \u003cSelect\u003e\n        \u003cOption value=\"admin\"\u003e管理员\u003c/Option\u003e\n        \u003cOption value=\"analyst\"\u003e安全分析师\u003c/Option\u003e\n        \u003cOption value=\"viewer\"\u003e只读用户\u003c/Option\u003e\n      \u003c/Select\u003e\n    \u003c/Form.Item\u003e\n    \u003cForm.Item name=\"password\" label=\"密码\"\u003e\n      \u003cInput.Password /\u003e\n    \u003c/Form.Item\u003e\n  \u003c/Form\u003e\n)\n```\n\n### 3. 角色管理页面\n```typescript\nconst RoleManagement: React.FC = () =\u003e {\n  const { data: roles } = useQuery(['roles'], fetchRoles)\n\n  return (\n    \u003cCard title=\"角色管理\"\u003e\n      \u003cList\n        dataSource={roles}\n        renderItem={role =\u003e (\n          \u003cList.Item actions={[\u003cButton onClick={() =\u003e editRole(role)}\u003e编辑权限\u003c/Button\u003e]}\u003e\n            \u003cList.Item.Meta\n              title={role.name}\n              description={role.description}\n            /\u003e\n            \u003cPermissionTags permissions={role.permissions} /\u003e\n          \u003c/List.Item\u003e\n        )}\n      /\u003e\n    \u003c/Card\u003e\n  )\n}\n```\n\n### 4. 权限配置\n```typescript\nconst PermissionConfig: React.FC\u003c{ role: Role }\u003e = ({ role }) =\u003e (\n  \u003cForm initialValues={{ permissions: role.permissions }}\u003e\n    \u003cForm.Item name=\"permissions\"\u003e\n      \u003cTree\n        checkable\n        treeData={[\n          { title: '告警管理', key: 'alerts', children: [\n            { title: '查看告警', key: 'alerts:read' },\n            { title: '处置告警', key: 'alerts:write' },\n          ]},\n          { title: '终端管理', key: 'endpoints', children: [\n            { title: '查看终端', key: 'endpoints:read' },\n            { title: '操作终端', key: 'endpoints:write' },\n          ]},\n          { title: '策略管理', key: 'policies', children: [\n            { title: '查看策略', key: 'policies:read' },\n            { title: '编辑策略', key: 'policies:write' },\n          ]},\n          { title: '系统管理', key: 'system', children: [\n            { title: '用户管理', key: 'system:users' },\n            { title: '审计日志', key: 'system:audit' },\n          ]},\n        ]}\n      /\u003e\n    \u003c/Form.Item\u003e\n  \u003c/Form\u003e\n)\n```\n\n### 5. 用户登录/注销\n```typescript\nconst LoginPage: React.FC = () =\u003e {\n  const login = useAuthStore(state =\u003e state.login)\n  \n  return (\n    \u003cForm onFinish={login}\u003e\n      \u003cForm.Item name=\"username\" rules={[{ required: true }]}\u003e\n        \u003cInput prefix={\u003cUserOutlined /\u003e} placeholder=\"用户名\" /\u003e\n      \u003c/Form.Item\u003e\n      \u003cForm.Item name=\"password\" rules={[{ required: true }]}\u003e\n        \u003cInput.Password prefix={\u003cLockOutlined /\u003e} placeholder=\"密码\" /\u003e\n      \u003c/Form.Item\u003e\n      \u003cButton type=\"primary\" htmlType=\"submit\" block\u003e登录\u003c/Button\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n### 6. 密码策略\n```typescript\nconst PasswordPolicy = {\n  minLength: 8,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumber: true,\n  requireSpecial: true,\n  expiryDays: 90,\n}\n\nconst validatePassword = (password: string): ValidationResult =\u003e {\n  // 验证密码是否符合策略\n}\n```\n\n### 7. 操作审计日志查看\n```typescript\nconst AuditLog: React.FC = () =\u003e {\n  const { data: logs } = useQuery(['auditLogs'], fetchAuditLogs)\n\n  return (\n    \u003cTable\n      dataSource={logs}\n      columns={[\n        { title: '时间', dataIndex: 'timestamp' },\n        { title: '用户', dataIndex: 'username' },\n        { title: '操作', dataIndex: 'action' },\n        { title: '资源', dataIndex: 'resource' },\n        { title: 'IP地址', dataIndex: 'ipAddress' },\n        { title: '详情', render: (_, record) =\u003e \u003cAuditDetail log={record} /\u003e }\n      ]}\n    /\u003e\n  )\n}\n```\n\n### 8. 会话管理\n```typescript\nconst SessionManagement: React.FC = () =\u003e {\n  const { data: sessions } = useQuery(['sessions'], fetchActiveSessions)\n\n  return (\n    \u003cCard title=\"活动会话\"\u003e\n      \u003cList\n        dataSource={sessions}\n        renderItem={session =\u003e (\n          \u003cList.Item \n            actions={[\n              \u003cButton danger onClick={() =\u003e terminateSession(session.id)}\u003e终止\u003c/Button\u003e\n            ]}\n          \u003e\n            \u003cList.Item.Meta\n              title={session.device}\n              description={`IP: ${session.ip} | 登录时间: ${session.loginTime}`}\n            /\u003e\n          \u003c/List.Item\u003e\n        )}\n      /\u003e\n    \u003c/Card\u003e\n  )\n}\n```\n\n### 项目结构\n```\nconsole/src/pages/Settings/\n├── Users/\n│   ├── index.tsx       # 用户列表\n│   └── UserForm.tsx    # 用户表单\n├── Roles/\n│   ├── index.tsx       # 角色列表\n│   └── PermissionConfig.tsx\n├── AuditLog/\n│   └── index.tsx       # 审计日志\n├── Sessions/\n│   └── index.tsx       # 会话管理\n└── styles.less\n```\n\n## 验收标准\n- [ ] 用户能正常登录\n- [ ] 用户CRUD功能正常\n- [ ] 权限控制生效\n- [ ] 审计日志可查看\n- [ ] 会话管理功能正常\n- [ ] 密码策略验证有效",
    "id": "task_1764425457707352000",
    "module": "Console",
    "name": "30-用户权限管理页面",
    "simhash": 17810003243150533000,
    "status": "todo",
    "updated_at": "2025-11-30T11:33:26+08:00"
  },
  {
    "created_at": "2025-11-29T22:11:11+08:00",
    "description": "实现关联分析引擎（Phase 2高级检测），包括：\n1. Apache Flink流处理框架集成\n2. 事件丰富化处理器\n3. 窗口聚合分析（滑动窗口）\n4. CEP复杂事件处理\n5. 攻击链模式匹配\n6. MITRE ATT\u0026CK战术映射\n7. 跨终端关联分析\n\n技术选型：\n- Apache Flink (Apache 2.0)\n- 自研攻击链规则引擎\n\n验收标准：\n- 能检测多步骤攻击链\n- MITRE映射正确\n- 关联告警生成",
    "id": "task_1764425471580691000",
    "module": "Cloud",
    "name": "31-关联分析引擎(Flink CEP)",
    "simhash": 590625793704193900,
    "status": "todo",
    "updated_at": "2025-11-29T22:11:11+08:00"
  },
  {
    "created_at": "2025-11-29T22:11:25+08:00",
    "description": "实现ML异常检测引擎（Phase 3高级检测），包括：\n1. 特征工程模块（进程/网络/文件特征提取）\n2. PyOD异常检测模型集成\n3. Isolation Forest模型\n4. 用户行为分析(UEBA)模型\n5. 模型训练Pipeline\n6. ONNX Runtime推理引擎\n7. MLflow模型版本管理\n8. 异常分数计算和告警\n\n技术选型：\n- PyOD (BSD 2-Clause)\n- scikit-learn (BSD 3-Clause)\n- ONNX Runtime (MIT)\n- MLflow (Apache 2.0)\n\n验收标准：\n- 模型能正常训练\n- 能检测异常行为\n- 模型可更新",
    "id": "task_1764425485234347000",
    "module": "Cloud",
    "name": "32-ML异常检测引擎",
    "simhash": 4087469204136653000,
    "status": "todo",
    "updated_at": "2025-11-29T22:11:25+08:00"
  },
  {
    "created_at": "2025-11-29T22:11:39+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: \n  - 02-Agent核心框架开发\n  - 42-MinIO对象存储 (取证数据存储)\n- **被依赖任务**: 无 (高级功能)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - Agent架构: C+Go混合\n  - 存储: MinIO (Apache 2.0)\n- **证据链**: SHA256完整性验证\n\n## 接口定义\n- **输入**: \n  - 取证任务命令 (gRPC)\n  - 采集目标 (文件/内存/进程)\n- **输出**: \n  - 取证数据包 → MinIO\n  - 完整性哈希\n\n## 任务内容\n\n实现远程取证模块（C+Go）：\n\n### C核心库实现 (agent/core-c/src/forensics/)\n\n1. **内存转储采集 - Windows** - memory_dump_win.c\n```c\n#include \u003cwindows.h\u003e\n#include \u003cdbghelp.h\u003e\n\nint dump_process_memory_win(DWORD pid, const char *output_path) {\n  HANDLE hProcess = OpenProcess(\n    PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);\n  if (hProcess == NULL) return -1;\n  \n  HANDLE hFile = CreateFileA(output_path, GENERIC_WRITE, 0, NULL,\n    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n  if (hFile == INVALID_HANDLE_VALUE) {\n    CloseHandle(hProcess);\n    return -1;\n  }\n  \n  // MiniDump with full memory\n  BOOL success = MiniDumpWriteDump(\n    hProcess,\n    pid,\n    hFile,\n    MiniDumpWithFullMemory | MiniDumpWithHandleData | MiniDumpWithThreadInfo,\n    NULL, NULL, NULL);\n  \n  CloseHandle(hFile);\n  CloseHandle(hProcess);\n  \n  return success ? 0 : -1;\n}\n```\n\n2. **内存转储采集 - Linux** - memory_dump_linux.c\n```c\n#include \u003csys/ptrace.h\u003e\n#include \u003csys/wait.h\u003e\n\nint dump_process_memory_linux(pid_t pid, const char *output_path) {\n  // Attach到进程\n  if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {\n    return -1;\n  }\n  waitpid(pid, NULL, 0);\n  \n  // 读取/proc/pid/maps获取内存映射\n  char maps_path[64];\n  snprintf(maps_path, sizeof(maps_path), \"/proc/%d/maps\", pid);\n  \n  FILE *maps = fopen(maps_path, \"r\");\n  FILE *output = fopen(output_path, \"wb\");\n  \n  char line[256];\n  while (fgets(line, sizeof(line), maps)) {\n    unsigned long start, end;\n    char perms[5];\n    sscanf(line, \"%lx-%lx %s\", \u0026start, \u0026end, perms);\n    \n    if (perms[0] == 'r') {  // 只读可读区域\n      // 从/proc/pid/mem读取内存内容\n      char mem_path[64];\n      snprintf(mem_path, sizeof(mem_path), \"/proc/%d/mem\", pid);\n      \n      FILE *mem = fopen(mem_path, \"rb\");\n      fseek(mem, start, SEEK_SET);\n      \n      size_t size = end - start;\n      void *buffer = malloc(size);\n      fread(buffer, 1, size, mem);\n      fwrite(buffer, 1, size, output);\n      \n      free(buffer);\n      fclose(mem);\n    }\n  }\n  \n  fclose(maps);\n  fclose(output);\n  \n  ptrace(PTRACE_DETACH, pid, NULL, NULL);\n  return 0;\n}\n```\n\n3. **进程快照采集** - process_snapshot.c\n```c\ntypedef struct {\n  uint32_t pid;\n  uint32_t ppid;\n  char name[256];\n  char executable[PATH_MAX];\n  char cmdline[4096];\n  char cwd[PATH_MAX];\n  char user[128];\n  uint64_t start_time;\n  \n  // 加载的模块\n  struct {\n    char path[PATH_MAX];\n    uint64_t base_address;\n    uint64_t size;\n  } modules[256];\n  int module_count;\n  \n  // 打开的文件句柄\n  struct {\n    char path[PATH_MAX];\n    int fd;\n  } open_files[256];\n  int file_count;\n  \n  // 网络连接\n  struct {\n    char local_addr[64];\n    int local_port;\n    char remote_addr[64];\n    int remote_port;\n    int protocol;\n    int state;\n  } connections[256];\n  int connection_count;\n  \n} process_snapshot_t;\n\nint capture_process_snapshot(uint32_t pid, process_snapshot_t *snapshot);\n```\n\n4. **文件采集器** - file_collector.c\n```c\ntypedef struct {\n  char pattern[PATH_MAX];   // glob模式\n  int recursive;            // 是否递归\n  uint64_t max_size;        // 单文件最大大小\n  uint64_t total_max_size;  // 总大小限制\n} file_collect_config_t;\n\ntypedef struct {\n  char path[PATH_MAX];\n  uint64_t size;\n  uint8_t sha256[32];\n  uint64_t mtime;\n  uint32_t mode;\n} collected_file_t;\n\nint collect_files(const file_collect_config_t *config, \n                  collected_file_t **files, int *count);\n```\n\n5. **数据打包** - archive.c\n```c\n#include \u003czip.h\u003e\n\ntypedef struct {\n  char archive_path[PATH_MAX];\n  char manifest_json[65536];  // 采集清单\n  uint8_t archive_sha256[32];\n  uint64_t timestamp;\n} forensic_archive_t;\n\nint create_forensic_archive(\n  const char *output_path,\n  collected_file_t *files, int file_count,\n  process_snapshot_t *snapshots, int snapshot_count,\n  const char *memory_dump_path,\n  forensic_archive_t *archive);\n```\n\n### Go业务层 (agent/main-go/internal/forensics/)\n\n6. **取证任务管理** - task_manager.go\n```go\ntype ForensicTask struct {\n  ID          string\n  Type        TaskType  // MEMORY_DUMP, FILE_COLLECT, PROCESS_SNAPSHOT\n  Status      TaskStatus\n  Target      interface{}\n  StartTime   time.Time\n  EndTime     time.Time\n  Result      *ForensicResult\n}\n\ntype ForensicsManager struct {\n  tasks    map[string]*ForensicTask\n  executor *CExecutor  // CGO调用\n  uploader *MinIOUploader\n}\n\nfunc (m *ForensicsManager) ExecuteTask(task *ForensicTask) error {\n  task.Status = TaskStatusRunning\n  task.StartTime = time.Now()\n  \n  switch task.Type {\n  case TaskTypeMemoryDump:\n    return m.collectMemoryDump(task)\n  case TaskTypeFileCollect:\n    return m.collectFiles(task)\n  case TaskTypeProcessSnapshot:\n    return m.captureProcessSnapshot(task)\n  }\n  return nil\n}\n```\n\n7. **证据链完整性** - integrity.go\n```go\ntype EvidenceChain struct {\n  TaskID      string\n  CollectedAt time.Time\n  AgentID     string\n  Hostname    string\n  Items       []EvidenceItem\n  ChainHash   string  // 整个证据链的SHA256\n}\n\ntype EvidenceItem struct {\n  Path        string\n  Size        int64\n  SHA256      string\n  CollectedAt time.Time\n  Type        string\n}\n\nfunc (e *EvidenceChain) ComputeChainHash() string {\n  h := sha256.New()\n  for _, item := range e.Items {\n    h.Write([]byte(item.SHA256))\n  }\n  return hex.EncodeToString(h.Sum(nil))\n}\n\nfunc (e *EvidenceChain) Verify() bool {\n  return e.ChainHash == e.ComputeChainHash()\n}\n```\n\n8. **MinIO上传** - uploader.go\n```go\nimport \"github.com/minio/minio-go/v7\"\n\ntype MinIOUploader struct {\n  client     *minio.Client\n  bucketName string\n}\n\nfunc (u *MinIOUploader) UploadForensicArchive(archive *ForensicArchive) (*UploadResult, error) {\n  objectName := fmt.Sprintf(\"forensics/%s/%s/%s.zip\",\n    archive.AgentID, \n    archive.Timestamp.Format(\"2006-01-02\"),\n    archive.TaskID)\n  \n  _, err := u.client.FPutObject(\n    context.Background(),\n    u.bucketName,\n    objectName,\n    archive.LocalPath,\n    minio.PutObjectOptions{\n      ContentType: \"application/zip\",\n      UserMetadata: map[string]string{\n        \"sha256\": archive.SHA256,\n        \"agent-id\": archive.AgentID,\n        \"task-id\": archive.TaskID,\n      },\n    },\n  )\n  \n  return \u0026UploadResult{\n    ObjectName: objectName,\n    URL:        u.client.EndpointURL().String() + \"/\" + u.bucketName + \"/\" + objectName,\n  }, err\n}\n```\n\n9. **取证命令处理** - command_handler.go\n```go\nfunc (m *ForensicsManager) HandleCommand(cmd *pb.ForensicCommand) *pb.ForensicResult {\n  task := \u0026ForensicTask{\n    ID:   cmd.TaskId,\n    Type: TaskType(cmd.Type),\n  }\n  \n  switch cmd.Type {\n  case pb.ForensicType_MEMORY_DUMP:\n    task.Target = \u0026MemoryDumpTarget{PID: cmd.GetMemoryDump().Pid}\n  case pb.ForensicType_FILE_COLLECT:\n    task.Target = \u0026FileCollectTarget{\n      Patterns:  cmd.GetFileCollect().Patterns,\n      Recursive: cmd.GetFileCollect().Recursive,\n    }\n  }\n  \n  if err := m.ExecuteTask(task); err != nil {\n    return \u0026pb.ForensicResult{\n      TaskId:  task.ID,\n      Success: false,\n      Error:   err.Error(),\n    }\n  }\n  \n  return \u0026pb.ForensicResult{\n    TaskId:   task.ID,\n    Success:  true,\n    ArchiveUrl: task.Result.ArchiveURL,\n    ChainHash:  task.Result.ChainHash,\n  }\n}\n```\n\n### 项目结构\n```\nagent/core-c/src/forensics/\n├── memory_dump_win.c     # Windows内存转储\n├── memory_dump_linux.c   # Linux内存转储\n├── process_snapshot.c    # 进程快照\n├── file_collector.c      # 文件采集\n├── archive.c             # 数据打包\n└── CMakeLists.txt\n\nagent/main-go/internal/forensics/\n├── task_manager.go       # 任务管理\n├── integrity.go          # 完整性验证\n├── uploader.go           # MinIO上传\n├── command_handler.go    # 命令处理\n└── cgo.go               # CGO封装\n```\n\n## 验收标准\n- [ ] 能远程采集文件\n- [ ] 能采集进程快照\n- [ ] 能采集进程内存转储\n- [ ] 数据正确打包为ZIP\n- [ ] SHA256完整性可验证\n- [ ] 数据上传MinIO成功\n- [ ] 跨平台支持(Windows/Linux/macOS)",
    "id": "task_1764425499430584000",
    "module": "Agent",
    "name": "33-远程取证模块",
    "simhash": 11340025791111743000,
    "status": "todo",
    "updated_at": "2025-11-30T11:46:36+08:00"
  },
  {
    "created_at": "2025-11-29T22:13:11+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 16-PostgreSQL配置存储\n- **被依赖任务**: \n  - 35-RBAC权限控制系统 (权限隔离)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - 数据库: PostgreSQL\n  - 隔离策略: 行级安全(RLS)\n\n## 接口定义\n- **输入**: \n  - 租户上下文 (tenant_id)\n  - 所有数据操作请求\n- **输出**: \n  - 隔离后的数据视图\n\n## 任务内容\n\n实现多租户数据隔离架构：\n\n### 1. PostgreSQL行级安全(RLS)配置\n```sql\n-- migrations/002_rls_policies.sql\n\n-- 启用RLS\nALTER TABLE assets ENABLE ROW LEVEL SECURITY;\nALTER TABLE alerts ENABLE ROW LEVEL SECURITY;\nALTER TABLE policies ENABLE ROW LEVEL SECURITY;\nALTER TABLE events ENABLE ROW LEVEL SECURITY;\n\n-- 创建应用角色\nCREATE ROLE edr_app;\nGRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO edr_app;\n\n-- 资产表RLS策略\nCREATE POLICY tenant_isolation_assets ON assets\n  USING (tenant_id = current_setting('app.current_tenant')::uuid);\n\n-- 告警表RLS策略\nCREATE POLICY tenant_isolation_alerts ON alerts\n  USING (tenant_id = current_setting('app.current_tenant')::uuid);\n\n-- 策略表RLS策略\nCREATE POLICY tenant_isolation_policies ON policies\n  USING (tenant_id = current_setting('app.current_tenant')::uuid);\n\n-- 允许超级管理员访问所有数据\nCREATE POLICY admin_bypass ON assets\n  USING (current_setting('app.is_admin', true)::boolean = true);\n```\n\n### 2. tenant_id字段自动注入\n```go\n// cloud/pkg/database/tenant.go\ntype TenantContext struct {\n  TenantID uuid.UUID\n  IsAdmin  bool\n}\n\nfunc SetTenantContext(ctx context.Context, tx *sql.Tx, tenant *TenantContext) error {\n  _, err := tx.ExecContext(ctx, \n    \"SET LOCAL app.current_tenant = $1; SET LOCAL app.is_admin = $2\",\n    tenant.TenantID.String(),\n    tenant.IsAdmin,\n  )\n  return err\n}\n\n// 数据库中间件\nfunc TenantMiddleware(db *sql.DB) func(http.Handler) http.Handler {\n  return func(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n      tenant := GetTenantFromContext(r.Context())\n      \n      tx, _ := db.BeginTx(r.Context(), nil)\n      SetTenantContext(r.Context(), tx, tenant)\n      \n      ctx := context.WithValue(r.Context(), \"tx\", tx)\n      next.ServeHTTP(w, r.WithContext(ctx))\n      \n      tx.Commit()\n    })\n  }\n}\n```\n\n### 3. 租户上下文传播\n```go\n// cloud/pkg/tenant/context.go\ntype tenantKey struct{}\n\nfunc WithTenant(ctx context.Context, tenant *Tenant) context.Context {\n  return context.WithValue(ctx, tenantKey{}, tenant)\n}\n\nfunc GetTenant(ctx context.Context) *Tenant {\n  if t, ok := ctx.Value(tenantKey{}).(*Tenant); ok {\n    return t\n  }\n  return nil\n}\n\n// gRPC拦截器\nfunc TenantInterceptor() grpc.UnaryServerInterceptor {\n  return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n    md, _ := metadata.FromIncomingContext(ctx)\n    tenantID := md.Get(\"x-tenant-id\")[0]\n    \n    tenant, _ := tenantService.GetByID(tenantID)\n    ctx = WithTenant(ctx, tenant)\n    \n    return handler(ctx, req)\n  }\n}\n```\n\n### 4. 租户管理服务\n```go\n// cloud/internal/tenant/service.go\ntype TenantService struct {\n  repo *TenantRepository\n  keyManager *KeyManager\n}\n\ntype Tenant struct {\n  ID          uuid.UUID\n  Name        string\n  Domain      string\n  Status      string\n  Config      TenantConfig\n  EncryptionKey []byte  // 租户专用加密密钥\n  CreatedAt   time.Time\n}\n\ntype TenantConfig struct {\n  MaxAgents       int\n  RetentionDays   int\n  Features        []string\n  DataRegion      string\n}\n\nfunc (s *TenantService) Create(tenant *Tenant) error {\n  // 生成租户加密密钥\n  key, _ := s.keyManager.GenerateKey()\n  tenant.EncryptionKey = key\n  \n  return s.repo.Create(tenant)\n}\n\nfunc (s *TenantService) GetByID(id uuid.UUID) (*Tenant, error) {\n  return s.repo.GetByID(id)\n}\n```\n\n### 5. 独立加密密钥管理\n```go\n// cloud/pkg/crypto/tenant_keys.go\ntype TenantKeyManager struct {\n  vault *vault.Client\n}\n\nfunc (m *TenantKeyManager) GenerateKey() ([]byte, error) {\n  key := make([]byte, 32)\n  _, err := rand.Read(key)\n  return key, err\n}\n\nfunc (m *TenantKeyManager) StoreKey(tenantID string, key []byte) error {\n  _, err := m.vault.Logical().Write(\n    fmt.Sprintf(\"secret/data/tenants/%s/encryption\", tenantID),\n    map[string]interface{}{\"key\": base64.StdEncoding.EncodeToString(key)},\n  )\n  return err\n}\n\nfunc (m *TenantKeyManager) GetKey(tenantID string) ([]byte, error) {\n  secret, _ := m.vault.Logical().Read(\n    fmt.Sprintf(\"secret/data/tenants/%s/encryption\", tenantID),\n  )\n  return base64.StdEncoding.DecodeString(secret.Data[\"key\"].(string))\n}\n\n// 使用租户密钥加密敏感字段\nfunc EncryptWithTenantKey(tenantID string, plaintext []byte) ([]byte, error) {\n  key, _ := keyManager.GetKey(tenantID)\n  return EncryptAESGCM(plaintext, key)\n}\n```\n\n### 6. OpenSearch索引隔离\n```go\n// cloud/pkg/opensearch/tenant.go\nfunc GetTenantIndexName(tenantID string, indexType string, date time.Time) string {\n  return fmt.Sprintf(\"tenant-%s-%s-%s\", \n    tenantID, \n    indexType, \n    date.Format(\"2006.01.02\"))\n}\n\n// 查询时自动添加租户过滤\nfunc BuildTenantQuery(tenantID string, userQuery map[string]interface{}) map[string]interface{} {\n  return map[string]interface{}{\n    \"bool\": map[string]interface{}{\n      \"must\": []interface{}{\n        userQuery,\n        map[string]interface{}{\n          \"term\": map[string]interface{}{\n            \"tenant_id\": tenantID,\n          },\n        },\n      },\n    },\n  }\n}\n```\n\n### 7. Kafka Topic隔离\n```go\n// 每个租户单独的Topic\nfunc GetTenantTopic(tenantID, topicType string) string {\n  return fmt.Sprintf(\"tenant.%s.%s\", tenantID, topicType)\n}\n\n// 或者使用消息头过滤\nfunc ProduceWithTenant(producer *kafka.Producer, tenantID string, msg *kafka.Message) error {\n  msg.Headers = append(msg.Headers, kafka.Header{\n    Key:   \"tenant-id\",\n    Value: []byte(tenantID),\n  })\n  return producer.Produce(msg, nil)\n}\n```\n\n### 项目结构\n```\ncloud/pkg/tenant/\n├── context.go        # 租户上下文\n├── middleware.go     # HTTP/gRPC中间件\n└── interceptor.go    # gRPC拦截器\n\ncloud/internal/tenant/\n├── service.go        # 租户服务\n├── repository.go     # 数据存储\n└── api.go            # 管理API\n\ncloud/pkg/crypto/\n├── tenant_keys.go    # 租户密钥管理\n\nmigrations/\n├── 002_rls_policies.sql  # RLS策略\n```\n\n## 验收标准\n- [ ] RLS策略正确应用\n- [ ] 不同租户数据完全隔离\n- [ ] 租户上下文正确传播\n- [ ] 租户密钥独立管理\n- [ ] OpenSearch索引隔离\n- [ ] Kafka消息隔离\n- [ ] 超管可跨租户访问",
    "id": "task_1764425591582020000",
    "module": "Cloud",
    "name": "34-多租户数据隔离实现",
    "simhash": 10502012902023800000,
    "status": "todo",
    "updated_at": "2025-11-30T11:49:24+08:00"
  },
  {
    "created_at": "2025-11-29T22:13:22+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 34-多租户数据隔离实现\n- **被依赖任务**: \n  - 30-用户权限管理页面 (权限校验)\n  - 43-审计日志与合规报告 (操作审计)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - 权限框架: **Casbin** (Apache 2.0)\n  - 存储: PostgreSQL\n- **权限模型**: RBAC with 层级继承\n\n## 接口定义\n- **输入**: \n  - 用户认证信息 (JWT)\n  - 资源访问请求\n- **输出**: \n  - 授权决策 (Allow/Deny)\n  - 权限列表API\n\n## 任务内容\n\n实现基于角色的访问控制(RBAC)系统：\n\n### 1. Casbin策略引擎集成\n```go\n// cloud/internal/auth/enforcer.go\nimport \"github.com/casbin/casbin/v2\"\n\ntype RBACEnforcer struct {\n  enforcer *casbin.Enforcer\n}\n\nfunc NewRBACEnforcer(modelPath, policyPath string) (*RBACEnforcer, error) {\n  e, err := casbin.NewEnforcer(modelPath, policyPath)\n  if err != nil {\n    return nil, err\n  }\n  return \u0026RBACEnforcer{enforcer: e}, nil\n}\n\nfunc (r *RBACEnforcer) CheckPermission(sub, obj, act string) bool {\n  allowed, _ := r.enforcer.Enforce(sub, obj, act)\n  return allowed\n}\n```\n\n### 2. RBAC模型定义\n```ini\n# model.conf\n[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub, obj, act\n\n[role_definition]\ng = _, _\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = g(r.sub, p.sub) \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act\n```\n\n### 3. 预定义角色设计\n```go\nconst (\n  RoleTenantAdmin    = \"tenant_admin\"     // 租户管理员\n  RoleSecurityAnalyst = \"security_analyst\" // 安全分析师\n  RoleAuditor        = \"auditor\"          // 只读审计员\n)\n\nvar DefaultPolicies = [][]string{\n  // 租户管理员 - 全部权限\n  {\"tenant_admin\", \"alerts\", \"read\"},\n  {\"tenant_admin\", \"alerts\", \"write\"},\n  {\"tenant_admin\", \"endpoints\", \"read\"},\n  {\"tenant_admin\", \"endpoints\", \"write\"},\n  {\"tenant_admin\", \"policies\", \"read\"},\n  {\"tenant_admin\", \"policies\", \"write\"},\n  {\"tenant_admin\", \"users\", \"read\"},\n  {\"tenant_admin\", \"users\", \"write\"},\n  {\"tenant_admin\", \"audit\", \"read\"},\n  \n  // 安全分析师 - 告警和终端操作权限\n  {\"security_analyst\", \"alerts\", \"read\"},\n  {\"security_analyst\", \"alerts\", \"write\"},\n  {\"security_analyst\", \"endpoints\", \"read\"},\n  {\"security_analyst\", \"endpoints\", \"write\"},\n  {\"security_analyst\", \"policies\", \"read\"},\n  \n  // 审计员 - 只读权限\n  {\"auditor\", \"alerts\", \"read\"},\n  {\"auditor\", \"endpoints\", \"read\"},\n  {\"auditor\", \"policies\", \"read\"},\n  {\"auditor\", \"audit\", \"read\"},\n}\n```\n\n### 4. 动态权限分配\n```go\nfunc (r *RBACEnforcer) AssignRole(userID, role string) error {\n  _, err := r.enforcer.AddGroupingPolicy(userID, role)\n  return err\n}\n\nfunc (r *RBACEnforcer) RevokeRole(userID, role string) error {\n  _, err := r.enforcer.RemoveGroupingPolicy(userID, role)\n  return err\n}\n\nfunc (r *RBACEnforcer) GetUserRoles(userID string) []string {\n  roles, _ := r.enforcer.GetRolesForUser(userID)\n  return roles\n}\n```\n\n### 5. 权限继承层级\n```go\n// 角色继承关系\nvar RoleHierarchy = map[string][]string{\n  \"tenant_admin\":     {\"security_analyst\"},\n  \"security_analyst\": {\"auditor\"},\n}\n\nfunc (r *RBACEnforcer) SetupHierarchy() {\n  for parent, children := range RoleHierarchy {\n    for _, child := range children {\n      r.enforcer.AddGroupingPolicy(parent, child)\n    }\n  }\n}\n```\n\n### 6. API级别授权中间件\n```go\n// cloud/internal/auth/middleware.go\nfunc RBACMiddleware(enforcer *RBACEnforcer) func(http.Handler) http.Handler {\n  return func(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n      user := GetUserFromContext(r.Context())\n      resource := extractResource(r.URL.Path)\n      action := mapMethodToAction(r.Method)\n      \n      if !enforcer.CheckPermission(user.ID, resource, action) {\n        http.Error(w, \"Forbidden\", http.StatusForbidden)\n        return\n      }\n      \n      next.ServeHTTP(w, r)\n    })\n  }\n}\n\nfunc mapMethodToAction(method string) string {\n  switch method {\n  case \"GET\":\n    return \"read\"\n  case \"POST\", \"PUT\", \"PATCH\", \"DELETE\":\n    return \"write\"\n  default:\n    return \"read\"\n  }\n}\n```\n\n### 7. gRPC授权拦截器\n```go\nfunc RBACInterceptor(enforcer *RBACEnforcer) grpc.UnaryServerInterceptor {\n  return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n    user := GetUserFromContext(ctx)\n    resource, action := extractFromMethod(info.FullMethod)\n    \n    if !enforcer.CheckPermission(user.ID, resource, action) {\n      return nil, status.Error(codes.PermissionDenied, \"permission denied\")\n    }\n    \n    return handler(ctx, req)\n  }\n}\n```\n\n### 8. 权限管理API\n```go\n// POST /api/v1/roles\n// GET /api/v1/roles\n// PUT /api/v1/roles/{id}\n// DELETE /api/v1/roles/{id}\n// POST /api/v1/users/{id}/roles\n// DELETE /api/v1/users/{id}/roles/{role}\n// GET /api/v1/users/{id}/permissions\n```\n\n### 项目结构\n```\ncloud/internal/auth/\n├── enforcer.go       # Casbin封装\n├── model.conf        # RBAC模型\n├── policies.go       # 预定义策略\n├── middleware.go     # HTTP中间件\n├── interceptor.go    # gRPC拦截器\n├── roles.go          # 角色管理\n└── api.go            # 权限API\n```\n\n## 验收标准\n- [ ] Casbin策略引擎正常加载\n- [ ] 预定义角色权限正确\n- [ ] 动态权限分配生效\n- [ ] 权限继承关系正确\n- [ ] HTTP API授权检查生效\n- [ ] gRPC调用授权检查生效\n- [ ] 权限变更实时生效",
    "id": "task_1764425602475041000",
    "module": "Cloud",
    "name": "35-RBAC权限控制系统",
    "simhash": 662097348044453200,
    "status": "todo",
    "updated_at": "2025-11-30T12:12:59+08:00"
  },
  {
    "created_at": "2025-11-29T22:13:32+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 19-告警生成与管理服务\n- **被依赖任务**: 无 (通知服务)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n- **通知渠道**: 邮件, Webhook, 企业微信, 钉钉, Slack\n\n## 接口定义\n- **输入**: \n  - 告警事件\n  - 通知配置\n- **输出**: \n  - 通知消息 → 各渠道\n\n## 任务内容\n\n实现告警通知服务：\n\n### 1. 通知渠道接口\n```go\n// cloud/internal/notification/channel.go\ntype NotificationChannel interface {\n  Name() string\n  Send(ctx context.Context, notification *Notification) error\n  Validate(config map[string]interface{}) error\n}\n\ntype Notification struct {\n  ID        string\n  AlertID   string\n  Title     string\n  Message   string\n  Severity  string\n  Timestamp time.Time\n  Metadata  map[string]string\n}\n```\n\n### 2. 邮件通知\n```go\n// cloud/internal/notification/channels/email.go\nimport \"gopkg.in/gomail.v2\"\n\ntype EmailChannel struct {\n  dialer *gomail.Dialer\n  from   string\n}\n\nfunc (c *EmailChannel) Send(ctx context.Context, n *Notification) error {\n  m := gomail.NewMessage()\n  m.SetHeader(\"From\", c.from)\n  m.SetHeader(\"To\", n.Metadata[\"to\"])\n  m.SetHeader(\"Subject\", fmt.Sprintf(\"[%s] %s\", n.Severity, n.Title))\n  m.SetBody(\"text/html\", c.renderTemplate(n))\n  \n  return c.dialer.DialAndSend(m)\n}\n\nfunc (c *EmailChannel) renderTemplate(n *Notification) string {\n  tmpl := template.Must(template.ParseFiles(\"templates/alert_email.html\"))\n  var buf bytes.Buffer\n  tmpl.Execute(\u0026buf, n)\n  return buf.String()\n}\n```\n\n### 3. Webhook通知\n```go\n// cloud/internal/notification/channels/webhook.go\ntype WebhookChannel struct {\n  client *http.Client\n}\n\nfunc (c *WebhookChannel) Send(ctx context.Context, n *Notification) error {\n  payload := map[string]interface{}{\n    \"alert_id\":  n.AlertID,\n    \"title\":     n.Title,\n    \"message\":   n.Message,\n    \"severity\":  n.Severity,\n    \"timestamp\": n.Timestamp.Format(time.RFC3339),\n    \"metadata\":  n.Metadata,\n  }\n  \n  body, _ := json.Marshal(payload)\n  \n  req, _ := http.NewRequestWithContext(ctx, \"POST\", n.Metadata[\"url\"], bytes.NewReader(body))\n  req.Header.Set(\"Content-Type\", \"application/json\")\n  \n  // 添加签名\n  if secret := n.Metadata[\"secret\"]; secret != \"\" {\n    signature := hmac.New(sha256.New, []byte(secret))\n    signature.Write(body)\n    req.Header.Set(\"X-Signature\", hex.EncodeToString(signature.Sum(nil)))\n  }\n  \n  resp, err := c.client.Do(req)\n  if err != nil {\n    return err\n  }\n  defer resp.Body.Close()\n  \n  if resp.StatusCode \u003e= 400 {\n    return fmt.Errorf(\"webhook failed with status %d\", resp.StatusCode)\n  }\n  return nil\n}\n```\n\n### 4. 企业微信通知\n```go\n// cloud/internal/notification/channels/wecom.go\ntype WeComChannel struct {\n  corpID     string\n  corpSecret string\n  agentID    int\n  accessToken string\n  tokenExpiry time.Time\n}\n\nfunc (c *WeComChannel) Send(ctx context.Context, n *Notification) error {\n  if err := c.refreshToken(); err != nil {\n    return err\n  }\n  \n  payload := map[string]interface{}{\n    \"touser\":  n.Metadata[\"users\"],\n    \"msgtype\": \"markdown\",\n    \"agentid\": c.agentID,\n    \"markdown\": map[string]string{\n      \"content\": c.formatMarkdown(n),\n    },\n  }\n  \n  url := fmt.Sprintf(\"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s\", c.accessToken)\n  return c.post(ctx, url, payload)\n}\n\nfunc (c *WeComChannel) formatMarkdown(n *Notification) string {\n  return fmt.Sprintf(`### %s\n\u003e 严重性: \u003cfont color=\"%s\"\u003e%s\u003c/font\u003e\n\u003e 时间: %s\n\n%s\n\n[查看详情](https://edr.example.com/alerts/%s)`,\n    n.Title,\n    severityColor(n.Severity),\n    n.Severity,\n    n.Timestamp.Format(\"2006-01-02 15:04:05\"),\n    n.Message,\n    n.AlertID,\n  )\n}\n```\n\n### 5. 钉钉通知\n```go\n// cloud/internal/notification/channels/dingtalk.go\ntype DingTalkChannel struct {\n  webhook string\n  secret  string\n}\n\nfunc (c *DingTalkChannel) Send(ctx context.Context, n *Notification) error {\n  timestamp := time.Now().UnixMilli()\n  sign := c.sign(timestamp)\n  \n  url := fmt.Sprintf(\"%s\u0026timestamp=%d\u0026sign=%s\", c.webhook, timestamp, sign)\n  \n  payload := map[string]interface{}{\n    \"msgtype\": \"markdown\",\n    \"markdown\": map[string]string{\n      \"title\": n.Title,\n      \"text\":  c.formatMarkdown(n),\n    },\n    \"at\": map[string]interface{}{\n      \"atMobiles\": strings.Split(n.Metadata[\"at_mobiles\"], \",\"),\n    },\n  }\n  \n  return c.post(ctx, url, payload)\n}\n\nfunc (c *DingTalkChannel) sign(timestamp int64) string {\n  stringToSign := fmt.Sprintf(\"%d\\n%s\", timestamp, c.secret)\n  mac := hmac.New(sha256.New, []byte(c.secret))\n  mac.Write([]byte(stringToSign))\n  return base64.StdEncoding.EncodeToString(mac.Sum(nil))\n}\n```\n\n### 6. Slack通知\n```go\n// cloud/internal/notification/channels/slack.go\ntype SlackChannel struct {\n  webhookURL string\n}\n\nfunc (c *SlackChannel) Send(ctx context.Context, n *Notification) error {\n  payload := map[string]interface{}{\n    \"attachments\": []map[string]interface{}{\n      {\n        \"color\":  severitySlackColor(n.Severity),\n        \"title\":  n.Title,\n        \"text\":   n.Message,\n        \"fields\": []map[string]string{\n          {\"title\": \"Severity\", \"value\": n.Severity, \"short\": true},\n          {\"title\": \"Time\", \"value\": n.Timestamp.Format(time.RFC3339), \"short\": true},\n        },\n        \"actions\": []map[string]string{\n          {\"type\": \"button\", \"text\": \"View Alert\", \"url\": fmt.Sprintf(\"https://edr.example.com/alerts/%s\", n.AlertID)},\n        },\n      },\n    },\n  }\n  \n  body, _ := json.Marshal(payload)\n  _, err := http.Post(c.webhookURL, \"application/json\", bytes.NewReader(body))\n  return err\n}\n```\n\n### 7. 通知策略管理\n```go\n// cloud/internal/notification/policy.go\ntype NotificationPolicy struct {\n  ID           string\n  Name         string\n  TenantID     uuid.UUID\n  Enabled      bool\n  SeverityFilter []string  // [\"critical\", \"high\"]\n  Channels     []ChannelConfig\n  Schedule     *Schedule\n  Throttle     *ThrottleConfig\n}\n\ntype ChannelConfig struct {\n  Type   string                 // email, webhook, wecom, dingtalk, slack\n  Config map[string]interface{}\n}\n\ntype ThrottleConfig struct {\n  MaxPerHour   int\n  DedupeWindow time.Duration\n}\n\ntype Schedule struct {\n  Enabled   bool\n  Timezone  string\n  WorkHours []TimeRange\n}\n```\n\n### 8. 通知服务\n```go\n// cloud/internal/notification/service.go\ntype NotificationService struct {\n  channels map[string]NotificationChannel\n  policies *PolicyRepository\n  queue    *NotificationQueue\n}\n\nfunc (s *NotificationService) SendAlert(alert *Alert) error {\n  policies, _ := s.policies.GetByTenantAndSeverity(alert.TenantID, alert.Severity)\n  \n  for _, policy := range policies {\n    if !policy.Enabled {\n      continue\n    }\n    \n    // 检查调度\n    if !s.isInSchedule(policy.Schedule) {\n      continue\n    }\n    \n    // 检查限流\n    if s.isThrottled(alert, policy.Throttle) {\n      continue\n    }\n    \n    notification := s.buildNotification(alert)\n    \n    for _, chConfig := range policy.Channels {\n      channel := s.channels[chConfig.Type]\n      s.queue.Enqueue(notification, channel, chConfig.Config)\n    }\n  }\n  \n  return nil\n}\n\nfunc (s *NotificationService) isThrottled(alert *Alert, config *ThrottleConfig) bool {\n  // 检查是否超过限流阈值\n  // 检查是否重复告警\n}\n```\n\n### 项目结构\n```\ncloud/internal/notification/\n├── channel.go            # 通道接口\n├── channels/\n│   ├── email.go\n│   ├── webhook.go\n│   ├── wecom.go\n│   ├── dingtalk.go\n│   └── slack.go\n├── policy.go             # 通知策略\n├── service.go            # 通知服务\n├── queue.go              # 通知队列\n└── templates/\n    ├── alert_email.html\n    └── alert_slack.json\n```\n\n## 验收标准\n- [ ] 邮件通知正常发送\n- [ ] Webhook通知正常\n- [ ] 企业微信通知正常\n- [ ] 钉钉通知正常\n- [ ] Slack通知正常\n- [ ] 通知策略配置生效\n- [ ] 限流机制生效\n- [ ] 调度功能正常",
    "id": "task_1764425612297456000",
    "module": "Cloud",
    "name": "36-告警通知集成服务",
    "simhash": 14895651120169454000,
    "status": "todo",
    "updated_at": "2025-11-30T11:49:24+08:00"
  },
  {
    "created_at": "2025-11-29T22:13:42+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 15-OpenSearch事件存储\n- **被依赖任务**: \n  - 26-告警仪表板开发 (统计数据)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - 分析型数据库: **ClickHouse** (Apache 2.0)\n- **数据同步**: Kafka → ClickHouse\n\n## 接口定义\n- **输入**: \n  - 事件流 (Kafka Topic: edr.events.normalized)\n  - 告警数据\n- **输出**: \n  - 统计查询API\n  - 报表数据\n\n## 任务内容\n\n实现ClickHouse统计分析模块：\n\n### 1. ClickHouse表结构设计\n```sql\n-- 事件统计表 (按小时聚合)\nCREATE TABLE edr.event_stats_hourly\n(\n  tenant_id UUID,\n  hour DateTime,\n  event_type String,\n  event_count UInt64,\n  unique_hosts UInt32,\n  unique_users UInt32\n)\nENGINE = SummingMergeTree()\nPARTITION BY toYYYYMM(hour)\nORDER BY (tenant_id, hour, event_type);\n\n-- 告警统计表\nCREATE TABLE edr.alert_stats_daily\n(\n  tenant_id UUID,\n  date Date,\n  severity String,\n  alert_count UInt64,\n  resolved_count UInt64,\n  avg_resolution_time_minutes Float64\n)\nENGINE = SummingMergeTree()\nPARTITION BY toYYYYMM(date)\nORDER BY (tenant_id, date, severity);\n\n-- 终端活动统计\nCREATE TABLE edr.endpoint_stats_daily\n(\n  tenant_id UUID,\n  date Date,\n  agent_id String,\n  event_count UInt64,\n  alert_count UInt32,\n  online_minutes UInt32\n)\nENGINE = SummingMergeTree()\nPARTITION BY toYYYYMM(date)\nORDER BY (tenant_id, date, agent_id);\n```\n\n### 2. 实时聚合Materialized View\n```sql\n-- 事件实时聚合\nCREATE MATERIALIZED VIEW edr.event_stats_mv\nTO edr.event_stats_hourly\nAS SELECT\n  tenant_id,\n  toStartOfHour(timestamp) AS hour,\n  event_type,\n  count() AS event_count,\n  uniqExact(host_id) AS unique_hosts,\n  uniqExact(user_name) AS unique_users\nFROM edr.events_raw\nGROUP BY tenant_id, hour, event_type;\n```\n\n### 3. Go ClickHouse客户端\n```go\n// cloud/pkg/clickhouse/client.go\nimport \"github.com/ClickHouse/clickhouse-go/v2\"\n\ntype ClickHouseClient struct {\n  conn clickhouse.Conn\n}\n\nfunc NewClickHouseClient(dsn string) (*ClickHouseClient, error) {\n  conn, err := clickhouse.Open(\u0026clickhouse.Options{\n    Addr: []string{dsn},\n    Auth: clickhouse.Auth{\n      Database: \"edr\",\n      Username: \"default\",\n      Password: \"\",\n    },\n  })\n  return \u0026ClickHouseClient{conn: conn}, err\n}\n```\n\n### 4. 趋势分析查询\n```go\nfunc (c *ClickHouseClient) GetEventTrend(tenantID string, days int) ([]TrendPoint, error) {\n  query := `\n    SELECT \n      toDate(hour) as date,\n      sum(event_count) as total\n    FROM edr.event_stats_hourly\n    WHERE tenant_id = ? AND hour \u003e= now() - INTERVAL ? DAY\n    GROUP BY date\n    ORDER BY date\n  `\n  \n  rows, _ := c.conn.Query(context.Background(), query, tenantID, days)\n  // 解析结果\n}\n\nfunc (c *ClickHouseClient) GetAlertTrend(tenantID string, days int) ([]TrendPoint, error) {\n  query := `\n    SELECT \n      date,\n      severity,\n      sum(alert_count) as total\n    FROM edr.alert_stats_daily\n    WHERE tenant_id = ? AND date \u003e= today() - ?\n    GROUP BY date, severity\n    ORDER BY date, severity\n  `\n  // ...\n}\n```\n\n### 5. 安全指标计算 (MTTR/MTTD)\n```go\n// MTTD: Mean Time to Detect (平均检测时间)\nfunc (c *ClickHouseClient) CalculateMTTD(tenantID string, startDate, endDate time.Time) (float64, error) {\n  query := `\n    SELECT avg(detection_time_seconds) as mttd\n    FROM edr.alert_detection_log\n    WHERE tenant_id = ? AND created_at BETWEEN ? AND ?\n  `\n  // ...\n}\n\n// MTTR: Mean Time to Resolve (平均解决时间)\nfunc (c *ClickHouseClient) CalculateMTTR(tenantID string, startDate, endDate time.Time) (float64, error) {\n  query := `\n    SELECT avg(resolution_time_minutes) as mttr\n    FROM edr.alert_stats_daily\n    WHERE tenant_id = ? AND date BETWEEN ? AND ?\n      AND resolved_count \u003e 0\n  `\n  // ...\n}\n```\n\n### 6. 定时报表生成\n```go\ntype ReportGenerator struct {\n  ch       *ClickHouseClient\n  storage  *MinIOClient\n  notifier *NotificationService\n}\n\nfunc (g *ReportGenerator) GenerateWeeklyReport(tenantID string) (*Report, error) {\n  report := \u0026Report{\n    TenantID:  tenantID,\n    Period:    \"weekly\",\n    GeneratedAt: time.Now(),\n  }\n  \n  // 收集统计数据\n  report.EventStats, _ = g.ch.GetEventStats(tenantID, 7)\n  report.AlertStats, _ = g.ch.GetAlertStats(tenantID, 7)\n  report.TopThreats, _ = g.ch.GetTopThreats(tenantID, 7)\n  report.MTTD, _ = g.ch.CalculateMTTD(tenantID, weekAgo, now)\n  report.MTTR, _ = g.ch.CalculateMTTR(tenantID, weekAgo, now)\n  \n  // 生成PDF\n  pdfBytes, _ := g.renderPDF(report)\n  \n  // 存储到MinIO\n  objectName := fmt.Sprintf(\"reports/%s/weekly-%s.pdf\", tenantID, time.Now().Format(\"2006-01-02\"))\n  g.storage.Upload(objectName, pdfBytes)\n  \n  return report, nil\n}\n```\n\n### 7. 数据导出功能\n```go\nfunc (c *ClickHouseClient) ExportToCSV(query string, writer io.Writer) error {\n  rows, _ := c.conn.Query(context.Background(), query)\n  csvWriter := csv.NewWriter(writer)\n  \n  // 写入表头\n  columns := rows.ColumnTypes()\n  headers := make([]string, len(columns))\n  for i, col := range columns {\n    headers[i] = col.Name()\n  }\n  csvWriter.Write(headers)\n  \n  // 写入数据\n  for rows.Next() {\n    // ...\n  }\n  \n  csvWriter.Flush()\n  return nil\n}\n```\n\n### 8. 统计分析API\n```go\n// GET /api/v1/stats/events/trend\n// GET /api/v1/stats/alerts/trend\n// GET /api/v1/stats/endpoints/activity\n// GET /api/v1/stats/metrics/mttd\n// GET /api/v1/stats/metrics/mttr\n// POST /api/v1/reports/generate\n// GET /api/v1/reports/download/{id}\n```\n\n### 项目结构\n```\ncloud/internal/analytics/\n├── client.go         # ClickHouse客户端\n├── queries.go        # 查询封装\n├── metrics.go        # 安全指标计算\n├── reports.go        # 报表生成\n├── export.go         # 数据导出\n└── api.go            # 统计API\n\ncloud/migrations/clickhouse/\n├── 001_init_tables.sql\n├── 002_materialized_views.sql\n└── 003_indexes.sql\n```\n\n## 验收标准\n- [ ] ClickHouse表结构正确创建\n- [ ] 实时聚合正常工作\n- [ ] 事件趋势查询正确\n- [ ] 告警趋势查询正确\n- [ ] MTTR/MTTD计算准确\n- [ ] 定时报表生成成功\n- [ ] CSV导出功能正常\n- [ ] 查询性能满足要求 (P99 \u003c 500ms)",
    "id": "task_1764425622655057000",
    "module": "Cloud",
    "name": "37-ClickHouse统计分析模块",
    "simhash": 590627992727402000,
    "status": "todo",
    "updated_at": "2025-11-30T12:12:59+08:00"
  },
  {
    "created_at": "2025-11-29T22:13:54+08:00",
    "description": "实现SASE/ZTNA集成接口，包括终端信任评分API、设备健康状态接口、威胁等级同步、与零信任网关的联动响应(自动隔离/降权)、OAuth2/SAML身份联邦。",
    "id": "task_1764425634564551000",
    "module": "Cloud",
    "name": "38-SASE/ZTNA集成接口",
    "simhash": 590592808355350300,
    "status": "todo",
    "updated_at": "2025-11-29T22:13:54+08:00"
  },
  {
    "created_at": "2025-11-29T22:14:05+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 02-Agent核心框架开发\n- **被依赖任务**: 无 (部署运维)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - Agent架构: C+Go混合\n  - 打包工具: WiX (Windows), pkgbuild (macOS), fpm (Linux)\n- **签名要求**: 代码签名证书\n\n## 接口定义\n- **输入**: \n  - Agent源代码\n  - 版本配置\n  - 签名证书\n- **输出**: \n  - MSI安装包 (Windows)\n  - PKG安装包 (macOS)\n  - DEB/RPM安装包 (Linux)\n  - 升级包\n\n## 任务内容\n\n实现Agent安装包构建与升级管理：\n\n### 1. 多平台安装包构建\n```makefile\n# Makefile\n.PHONY: build-all build-windows build-linux build-macos\n\nVERSION := $(shell git describe --tags --always)\nBUILD_TIME := $(shell date -u +\"%Y-%m-%dT%H:%M:%SZ\")\n\nbuild-all: build-windows build-linux build-macos\n\nbuild-windows:\n\tGOOS=windows GOARCH=amd64 go build -ldflags \"-X main.Version=$(VERSION)\" -o build/windows/edr-agent.exe ./cmd/agent\n\t# 构建C核心库\n\tcmake -B build/windows/c-core -DCMAKE_TOOLCHAIN_FILE=cmake/windows.cmake\n\tcmake --build build/windows/c-core\n\nbuild-linux:\n\tGOOS=linux GOARCH=amd64 go build -ldflags \"-X main.Version=$(VERSION)\" -o build/linux/edr-agent ./cmd/agent\n\tcmake -B build/linux/c-core\n\tcmake --build build/linux/c-core\n\nbuild-macos:\n\tGOOS=darwin GOARCH=amd64 go build -ldflags \"-X main.Version=$(VERSION)\" -o build/macos/edr-agent ./cmd/agent\n\tGOOS=darwin GOARCH=arm64 go build -ldflags \"-X main.Version=$(VERSION)\" -o build/macos-arm/edr-agent ./cmd/agent\n```\n\n### 2. Windows MSI安装包 (WiX)\n```xml\n\u003c!-- agent/installer/windows/Product.wxs --\u003e\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003cWix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\"\u003e\n  \u003cProduct Id=\"*\" Name=\"EDR Agent\" Language=\"1033\" \n           Version=\"$(var.ProductVersion)\" Manufacturer=\"Company\"\n           UpgradeCode=\"YOUR-GUID-HERE\"\u003e\n    \n    \u003cPackage InstallerVersion=\"500\" Compressed=\"yes\" InstallScope=\"perMachine\"/\u003e\n    \n    \u003cMajorUpgrade DowngradeErrorMessage=\"已安装更新版本\"/\u003e\n    \u003cMediaTemplate EmbedCab=\"yes\"/\u003e\n    \n    \u003cFeature Id=\"ProductFeature\" Title=\"EDR Agent\" Level=\"1\"\u003e\n      \u003cComponentGroupRef Id=\"ProductComponents\"/\u003e\n      \u003cComponentRef Id=\"ServiceComponent\"/\u003e\n    \u003c/Feature\u003e\n    \n    \u003c!-- 安装目录 --\u003e\n    \u003cDirectory Id=\"TARGETDIR\" Name=\"SourceDir\"\u003e\n      \u003cDirectory Id=\"ProgramFiles64Folder\"\u003e\n        \u003cDirectory Id=\"INSTALLFOLDER\" Name=\"EDR Agent\"\u003e\n          \u003cComponent Id=\"MainExecutable\" Guid=\"*\"\u003e\n            \u003cFile Id=\"AgentExe\" Source=\"$(var.BuildDir)\\edr-agent.exe\" KeyPath=\"yes\"/\u003e\n            \u003cFile Id=\"CoreDll\" Source=\"$(var.BuildDir)\\edr-core.dll\"/\u003e\n          \u003c/Component\u003e\n          \u003cComponent Id=\"ConfigFiles\" Guid=\"*\"\u003e\n            \u003cFile Id=\"ConfigYaml\" Source=\"config\\agent.yaml\"/\u003e\n          \u003c/Component\u003e\n        \u003c/Directory\u003e\n      \u003c/Directory\u003e\n    \u003c/Directory\u003e\n    \n    \u003c!-- Windows服务 --\u003e\n    \u003cComponent Id=\"ServiceComponent\" Directory=\"INSTALLFOLDER\" Guid=\"*\"\u003e\n      \u003cServiceInstall Id=\"ServiceInstall\" Name=\"EDRAgent\" DisplayName=\"EDR Agent Service\"\n                      Type=\"ownProcess\" Start=\"auto\" ErrorControl=\"normal\"\n                      Account=\"LocalSystem\"/\u003e\n      \u003cServiceControl Id=\"ServiceControl\" Name=\"EDRAgent\" Start=\"install\" Stop=\"both\" Remove=\"uninstall\"/\u003e\n    \u003c/Component\u003e\n    \n    \u003c!-- 静默安装支持 --\u003e\n    \u003cProperty Id=\"ENROLLMENT_TOKEN\" Secure=\"yes\"/\u003e\n    \u003cCustomAction Id=\"SetEnrollmentToken\" Property=\"ENROLLMENT_TOKEN\" Value=\"[ENROLLMENT_TOKEN]\"/\u003e\n  \u003c/Product\u003e\n\u003c/Wix\u003e\n```\n\n### 3. macOS PKG安装包\n```bash\n#!/bin/bash\n# agent/installer/macos/build-pkg.sh\n\nVERSION=$1\nBUILD_DIR=\"build/macos\"\nPKG_DIR=\"pkg-root\"\n\n# 准备目录结构\nmkdir -p \"$PKG_DIR/Library/Application Support/EDR Agent\"\nmkdir -p \"$PKG_DIR/Library/LaunchDaemons\"\nmkdir -p \"$PKG_DIR/usr/local/bin\"\n\n# 复制文件\ncp \"$BUILD_DIR/edr-agent\" \"$PKG_DIR/usr/local/bin/\"\ncp \"config/agent.yaml\" \"$PKG_DIR/Library/Application Support/EDR Agent/\"\ncp \"installer/macos/com.company.edr-agent.plist\" \"$PKG_DIR/Library/LaunchDaemons/\"\n\n# 构建PKG\npkgbuild --root \"$PKG_DIR\" \\\n         --identifier \"com.company.edr-agent\" \\\n         --version \"$VERSION\" \\\n         --scripts \"installer/macos/scripts\" \\\n         --install-location \"/\" \\\n         \"EDR-Agent-$VERSION.pkg\"\n\n# 代码签名\nproductsign --sign \"Developer ID Installer: Company\" \\\n            \"EDR-Agent-$VERSION.pkg\" \\\n            \"EDR-Agent-$VERSION-signed.pkg\"\n```\n\n### 4. Linux DEB/RPM安装包\n```bash\n#!/bin/bash\n# agent/installer/linux/build-packages.sh\n\nVERSION=$1\nBUILD_DIR=\"build/linux\"\n\n# 使用fpm构建DEB\nfpm -s dir -t deb \\\n    -n edr-agent \\\n    -v $VERSION \\\n    --description \"EDR Agent for Linux\" \\\n    --vendor \"Company\" \\\n    --maintainer \"support@company.com\" \\\n    --after-install installer/linux/postinst.sh \\\n    --before-remove installer/linux/prerm.sh \\\n    --config-files /etc/edr-agent/agent.yaml \\\n    \"$BUILD_DIR/edr-agent=/usr/bin/edr-agent\" \\\n    \"config/agent.yaml=/etc/edr-agent/agent.yaml\" \\\n    \"installer/linux/edr-agent.service=/etc/systemd/system/edr-agent.service\"\n\n# 使用fpm构建RPM\nfpm -s dir -t rpm \\\n    -n edr-agent \\\n    -v $VERSION \\\n    --description \"EDR Agent for Linux\" \\\n    --vendor \"Company\" \\\n    --after-install installer/linux/postinst.sh \\\n    --before-remove installer/linux/prerm.sh \\\n    --config-files /etc/edr-agent/agent.yaml \\\n    \"$BUILD_DIR/edr-agent=/usr/bin/edr-agent\" \\\n    \"config/agent.yaml=/etc/edr-agent/agent.yaml\" \\\n    \"installer/linux/edr-agent.service=/etc/systemd/system/edr-agent.service\"\n```\n\n### 5. 静默安装脚本\n```powershell\n# Windows静默安装\n# install.ps1\nparam(\n    [string]$EnrollmentToken,\n    [string]$ServerURL = \"https://edr.company.com\"\n)\n\n$msiPath = \"$PSScriptRoot\\EDR-Agent.msi\"\n$logPath = \"$env:TEMP\\edr-agent-install.log\"\n\nStart-Process msiexec.exe -ArgumentList @(\n    \"/i\", $msiPath,\n    \"/qn\",  # 静默\n    \"/l*v\", $logPath,\n    \"ENROLLMENT_TOKEN=$EnrollmentToken\",\n    \"SERVER_URL=$ServerURL\"\n) -Wait -NoNewWindow\n\n# 验证安装\n$service = Get-Service -Name \"EDRAgent\" -ErrorAction SilentlyContinue\nif ($service -and $service.Status -eq \"Running\") {\n    Write-Host \"Installation successful\"\n} else {\n    Write-Error \"Installation failed\"\n    exit 1\n}\n```\n\n### 6. 增量升级机制\n```go\n// agent/main-go/internal/updater/updater.go\ntype Updater struct {\n  currentVersion string\n  serverURL      string\n  checkInterval  time.Duration\n}\n\ntype UpdateInfo struct {\n  Version     string `json:\"version\"`\n  ReleaseDate string `json:\"release_date\"`\n  DownloadURL string `json:\"download_url\"`\n  SHA256      string `json:\"sha256\"`\n  PatchURL    string `json:\"patch_url,omitempty\"`  // 增量包\n  PatchSHA256 string `json:\"patch_sha256,omitempty\"`\n  Mandatory   bool   `json:\"mandatory\"`\n  ReleaseNotes string `json:\"release_notes\"`\n}\n\nfunc (u *Updater) CheckForUpdate() (*UpdateInfo, error) {\n  resp, _ := http.Get(fmt.Sprintf(\"%s/api/v1/agent/updates?current=%s\", u.serverURL, u.currentVersion))\n  var info UpdateInfo\n  json.NewDecoder(resp.Body).Decode(\u0026info)\n  return \u0026info, nil\n}\n\nfunc (u *Updater) ApplyUpdate(info *UpdateInfo) error {\n  // 1. 下载更新包\n  var downloadURL string\n  if info.PatchURL != \"\" {\n    downloadURL = info.PatchURL  // 优先增量更新\n  } else {\n    downloadURL = info.DownloadURL\n  }\n  \n  // 2. 验证SHA256\n  // 3. 备份当前版本\n  // 4. 应用更新\n  // 5. 重启服务\n  return nil\n}\n```\n\n### 7. 版本灰度发布\n```go\n// cloud/internal/deployment/rollout.go\ntype RolloutConfig struct {\n  Version     string   `json:\"version\"`\n  Percentage  int      `json:\"percentage\"`  // 0-100\n  TargetGroups []string `json:\"target_groups\"`\n  Schedule    *Schedule `json:\"schedule,omitempty\"`\n}\n\nfunc (s *RolloutService) ShouldUpdate(agentID string, config *RolloutConfig) bool {\n  // 基于agentID哈希决定是否在灰度范围内\n  hash := hashAgent(agentID)\n  threshold := int(float64(config.Percentage) / 100.0 * float64(math.MaxInt32))\n  \n  return hash \u003c threshold\n}\n```\n\n### 8. 回滚策略\n```go\nfunc (u *Updater) Rollback() error {\n  backupPath := filepath.Join(u.dataDir, \"backup\", u.previousVersion)\n  \n  if _, err := os.Stat(backupPath); os.IsNotExist(err) {\n    return fmt.Errorf(\"backup not found for version %s\", u.previousVersion)\n  }\n  \n  // 停止服务\n  // 恢复备份\n  // 重启服务\n  return nil\n}\n```\n\n### 9. 升级状态追踪\n```go\ntype UpgradeStatus struct {\n  AgentID        string    `json:\"agent_id\"`\n  FromVersion    string    `json:\"from_version\"`\n  ToVersion      string    `json:\"to_version\"`\n  Status         string    `json:\"status\"` // pending/downloading/applying/completed/failed/rolled_back\n  StartedAt      time.Time `json:\"started_at\"`\n  CompletedAt    *time.Time `json:\"completed_at,omitempty\"`\n  ErrorMessage   string    `json:\"error_message,omitempty\"`\n}\n\n// GET /api/v1/agents/{id}/upgrade-status\n// GET /api/v1/deployments/{version}/status\n```\n\n### 项目结构\n```\nagent/installer/\n├── windows/\n│   ├── Product.wxs\n│   ├── build.bat\n│   └── install.ps1\n├── macos/\n│   ├── build-pkg.sh\n│   ├── com.company.edr-agent.plist\n│   └── scripts/\n│       ├── preinstall\n│       └── postinstall\n├── linux/\n│   ├── build-packages.sh\n│   ├── postinst.sh\n│   ├── prerm.sh\n│   └── edr-agent.service\n└── common/\n    └── config/\n        └── agent.yaml.template\n\nagent/main-go/internal/updater/\n├── updater.go\n├── downloader.go\n├── patcher.go\n└── rollback.go\n\ncloud/internal/deployment/\n├── rollout.go\n├── versions.go\n└── status.go\n```\n\n## 验收标准\n- [ ] Windows MSI包正常安装/卸载\n- [ ] macOS PKG包正常安装/卸载\n- [ ] Linux DEB/RPM包正常安装/卸载\n- [ ] 静默安装正常工作\n- [ ] 增量升级减少下载量 \u003e 50%\n- [ ] 灰度发布比例控制准确\n- [ ] 升级失败自动回滚\n- [ ] 升级状态正确追踪",
    "id": "task_1764425645671097000",
    "module": "Agent",
    "name": "39-Agent安装包与升级管理",
    "simhash": 590781924355310800,
    "status": "todo",
    "updated_at": "2025-11-30T12:12:59+08:00"
  },
  {
    "created_at": "2025-11-29T22:14:16+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 01-项目基础框架搭建\n- **被依赖任务**: 无 (基础设施)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - 可观测性: **OpenTelemetry Collector**\n  - 指标: Prometheus\n  - 仪表板: Grafana\n  - 追踪: Jaeger\n  - 日志: Loki\n\n## 接口定义\n- **输入**: \n  - OTLP Traces/Metrics/Logs\n  - Prometheus metrics endpoint\n- **输出**: \n  - Grafana仪表板\n  - 告警通知\n\n## 任务内容\n\n实现系统可观测性与运维监控：\n\n### 1. OpenTelemetry Collector配置\n```yaml\n# deploy/otel/otel-collector-config.yaml\nreceivers:\n  otlp:\n    protocols:\n      grpc:\n        endpoint: 0.0.0.0:4317\n      http:\n        endpoint: 0.0.0.0:4318\n\nprocessors:\n  batch:\n    timeout: 10s\n    send_batch_size: 1000\n\nexporters:\n  prometheus:\n    endpoint: \"0.0.0.0:8889\"\n  jaeger:\n    endpoint: jaeger-collector:14250\n  loki:\n    endpoint: http://loki:3100/loki/api/v1/push\n\nservice:\n  pipelines:\n    traces:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [jaeger]\n    metrics:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [prometheus]\n    logs:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [loki]\n```\n\n### 2. Go服务OTel集成\n```go\nimport (\n  \"go.opentelemetry.io/otel\"\n  \"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n  \"go.opentelemetry.io/otel/sdk/trace\"\n)\n\nfunc initTracer() (*trace.TracerProvider, error) {\n  exporter, _ := otlptracegrpc.New(ctx,\n    otlptracegrpc.WithEndpoint(\"otel-collector:4317\"),\n    otlptracegrpc.WithInsecure(),\n  )\n  \n  tp := trace.NewTracerProvider(\n    trace.WithBatcher(exporter),\n    trace.WithResource(resource.NewWithAttributes(\n      semconv.SchemaURL,\n      semconv.ServiceName(\"edr-cloud\"),\n    )),\n  )\n  otel.SetTracerProvider(tp)\n  return tp, nil\n}\n```\n\n### 3. Prometheus指标暴露\n```go\nimport \"github.com/prometheus/client_golang/prometheus\"\n\nvar (\n  eventsProcessed = prometheus.NewCounterVec(\n    prometheus.CounterOpts{\n      Name: \"edr_events_processed_total\",\n      Help: \"Total number of events processed\",\n    },\n    []string{\"type\", \"status\"},\n  )\n  \n  processingDuration = prometheus.NewHistogramVec(\n    prometheus.HistogramOpts{\n      Name:    \"edr_event_processing_duration_seconds\",\n      Help:    \"Event processing duration\",\n      Buckets: []float64{.001, .005, .01, .025, .05, .1, .25, .5, 1},\n    },\n    []string{\"type\"},\n  )\n)\n```\n\n### 4. Grafana仪表板配置\n```json\n// deploy/grafana/dashboards/edr-overview.json\n{\n  \"title\": \"EDR Platform Overview\",\n  \"panels\": [\n    {\n      \"title\": \"Events Processed\",\n      \"type\": \"stat\",\n      \"targets\": [\n        { \"expr\": \"sum(rate(edr_events_processed_total[5m]))\" }\n      ]\n    },\n    {\n      \"title\": \"Processing Latency P99\",\n      \"type\": \"timeseries\",\n      \"targets\": [\n        { \"expr\": \"histogram_quantile(0.99, rate(edr_event_processing_duration_seconds_bucket[5m]))\" }\n      ]\n    }\n  ]\n}\n```\n\n### 5. 分布式追踪 (Jaeger)\n```yaml\n# deploy/jaeger/values.yaml\ncollector:\n  service:\n    type: ClusterIP\nstorage:\n  type: elasticsearch\n  options:\n    es:\n      server-urls: http://opensearch:9200\n```\n\n### 6. 日志聚合 (Loki)\n```yaml\n# deploy/loki/values.yaml\nloki:\n  storage:\n    type: s3\n    bucketNames:\n      chunks: edr-loki-chunks\n```\n\n### 7. 健康检查端点\n```go\n// /health/live - 存活检查\n// /health/ready - 就绪检查\nfunc healthHandler(w http.ResponseWriter, r *http.Request) {\n  w.WriteHeader(http.StatusOK)\n  json.NewEncoder(w).Encode(map[string]string{\"status\": \"ok\"})\n}\n```\n\n### 8. 告警规则配置\n```yaml\n# deploy/prometheus/alerts.yaml\ngroups:\n- name: edr-alerts\n  rules:\n  - alert: HighEventProcessingLatency\n    expr: histogram_quantile(0.99, rate(edr_event_processing_duration_seconds_bucket[5m])) \u003e 1\n    for: 5m\n    labels:\n      severity: warning\n```\n\n### 项目结构\n```\ndeploy/\n├── otel/\n│   ├── otel-collector-config.yaml\n│   └── deployment.yaml\n├── prometheus/\n│   ├── prometheus.yaml\n│   └── alerts.yaml\n├── grafana/\n│   ├── values.yaml\n│   └── dashboards/\n│       ├── edr-overview.json\n│       ├── edr-agents.json\n│       └── edr-alerts.json\n├── jaeger/\n│   └── values.yaml\n└── loki/\n    └── values.yaml\n```\n\n## 验收标准\n- [ ] OTel Collector正常接收数据\n- [ ] Prometheus指标正常采集\n- [ ] Grafana仪表板正常展示\n- [ ] Jaeger追踪正常显示\n- [ ] Loki日志查询正常\n- [ ] 健康检查端点可用\n- [ ] 告警规则正常触发",
    "id": "task_1764425656162578000",
    "module": "Cloud",
    "name": "40-系统监控与可观测性",
    "simhash": 14119513384708723000,
    "status": "todo",
    "updated_at": "2025-11-30T11:30:34+08:00"
  },
  {
    "created_at": "2025-11-29T22:14:25+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 01-项目基础框架搭建\n- **被依赖任务**: 无 (基础设施)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - 镜像仓库: **Harbor** (Apache 2.0)\n  - 容器运行时: Docker\n  - 编排平台: Kubernetes\n  - 包管理: Helm\n\n## 接口定义\n- **输入**: 源代码、Dockerfile\n- **输出**: \n  - Docker镜像 → Harbor\n  - Kubernetes Deployment\n\n## 任务内容\n\n实现容器化部署方案：\n\n### 1. Docker镜像构建 (多阶段)\n```dockerfile\n# cloud/Dockerfile\n# 构建阶段\nFROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 go build -o /app/edr-cloud ./cmd/cloud\n\n# 运行阶段\nFROM gcr.io/distroless/static:nonroot\nCOPY --from=builder /app/edr-cloud /edr-cloud\nUSER nonroot:nonroot\nENTRYPOINT [\"/edr-cloud\"]\n```\n\n### 2. Harbor私有镜像仓库部署\n```yaml\n# deploy/harbor/values.yaml\nexpose:\n  type: ingress\n  ingress:\n    hosts:\n      core: harbor.edr.local\npersistence:\n  persistentVolumeClaim:\n    registry:\n      size: 100Gi\n```\n\n```bash\n# 部署Harbor\nhelm install harbor harbor/harbor -f values.yaml -n harbor\n\n# 推送镜像\ndocker tag edr-cloud:latest harbor.edr.local/edr/cloud:v1.0.0\ndocker push harbor.edr.local/edr/cloud:v1.0.0\n```\n\n### 3. 镜像漏洞扫描\n- Harbor内置Trivy扫描器\n- CI/CD集成扫描阶段\n- 漏洞阈值策略\n\n### 4. Helm Chart编写\n```yaml\n# deploy/helm/edr/Chart.yaml\napiVersion: v2\nname: edr\nversion: 1.0.0\ndescription: EDR Platform Helm Chart\n\n# deploy/helm/edr/values.yaml\ncloud:\n  replicas: 3\n  image:\n    repository: harbor.edr.local/edr/cloud\n    tag: v1.0.0\n  resources:\n    limits:\n      cpu: 2\n      memory: 4Gi\n```\n\n### 5. Kubernetes部署模板\n```yaml\n# templates/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ .Chart.Name }}-cloud\nspec:\n  replicas: {{ .Values.cloud.replicas }}\n  template:\n    spec:\n      containers:\n      - name: cloud\n        image: \"{{ .Values.cloud.image.repository }}:{{ .Values.cloud.image.tag }}\"\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8080\n        - containerPort: 8443\n```\n\n### 6. HPA自动扩缩容\n```yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: edr-cloud-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: edr-cloud\n  minReplicas: 3\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n```\n\n### 7. ConfigMap/Secret管理\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: edr-secrets\ntype: Opaque\ndata:\n  db-password: {{ .Values.database.password | b64enc }}\n  kafka-password: {{ .Values.kafka.password | b64enc }}\n```\n\n### 项目结构\n```\ndeploy/\n├── docker/\n│   ├── cloud.Dockerfile\n│   ├── gateway.Dockerfile\n│   └── console.Dockerfile\n├── harbor/\n│   └── values.yaml\n├── helm/\n│   └── edr/\n│       ├── Chart.yaml\n│       ├── values.yaml\n│       └── templates/\n│           ├── deployment.yaml\n│           ├── service.yaml\n│           ├── ingress.yaml\n│           ├── hpa.yaml\n│           ├── configmap.yaml\n│           └── secret.yaml\n└── kubernetes/\n    └── namespace.yaml\n```\n\n## 验收标准\n- [ ] Docker镜像正常构建\n- [ ] Harbor镜像仓库正常运行\n- [ ] 镜像漏洞扫描通过\n- [ ] Helm Chart可正常部署\n- [ ] HPA自动扩缩容生效\n- [ ] Secret/ConfigMap正确挂载\n- [ ] 服务健康检查通过",
    "id": "task_1764425665906725000",
    "module": "Cloud",
    "name": "41-容器化与K8s部署",
    "simhash": 9636183070516708,
    "status": "todo",
    "updated_at": "2025-11-30T11:29:12+08:00"
  },
  {
    "created_at": "2025-11-29T22:14:36+08:00",
    "description": "## 任务内容\n\n集成MinIO对象存储，用于取证数据与样本文件存储：\n\n### 1. MinIO客户端封装\n```go\nimport \"github.com/minio/minio-go/v7\"\n\ntype MinIOClient struct {\n  client     *minio.Client\n  bucketName string\n}\n\nfunc (c *MinIOClient) Upload(objectName string, reader io.Reader, size int64) error\nfunc (c *MinIOClient) Download(objectName string) (io.ReadCloser, error)\nfunc (c *MinIOClient) Delete(objectName string) error\nfunc (c *MinIOClient) GetPresignedURL(objectName string, expires time.Duration) (string, error)\n```\n\n### 2. 分块上传与断点续传\n```go\nfunc (c *MinIOClient) MultipartUpload(objectName string, filePath string) error {\n  // 分块大小: 10MB\n  // 支持断点续传\n}\n```\n\n### 3. 文件去重 (Content-Addressable)\n```go\nfunc (c *MinIOClient) UploadWithDedup(content []byte) (string, error) {\n  hash := sha256.Sum256(content)\n  objectName := hex.EncodeToString(hash[:])\n  // 检查是否已存在，存在则跳过上传\n}\n```\n\n### 4. Bucket生命周期配置\n- 取证数据: 90天后归档，180天删除\n- 样本文件: 永久保留\n- 临时文件: 7天删除\n\n### 5. 服务端加密\n```go\nopts := minio.PutObjectOptions{\n  ServerSideEncryption: encrypt.NewSSE(),\n}\n```\n\n## 验收标准\n- [ ] 分块上传/断点续传正常\n- [ ] 文件去重生效\n- [ ] 生命周期策略执行正确\n- [ ] 服务端加密启用\n- [ ] 预签名URL可用",
    "id": "task_1764425676598499000",
    "module": "Cloud",
    "name": "42-MinIO对象存储集成",
    "simhash": 590693962888128000,
    "status": "todo",
    "updated_at": "2025-11-30T12:19:16+08:00"
  },
  {
    "created_at": "2025-11-29T22:14:46+08:00",
    "description": "## 任务内容\n\n实现审计日志系统与合规报告：\n\n### 1. 审计事件记录\n```go\ntype AuditLog struct {\n  ID        string    `json:\"id\"`\n  Timestamp time.Time `json:\"timestamp\"`\n  UserID    string    `json:\"user_id\"`\n  Username  string    `json:\"username\"`\n  Action    string    `json:\"action\"`    // login/create/update/delete/execute\n  Resource  string    `json:\"resource\"`  // alerts/policies/endpoints/users\n  ResourceID string   `json:\"resource_id\"`\n  IPAddress string    `json:\"ip_address\"`\n  UserAgent string    `json:\"user_agent\"`\n  Details   map[string]interface{} `json:\"details\"`\n  Status    string    `json:\"status\"`    // success/failure\n}\n\nfunc (s *AuditService) Log(ctx context.Context, event *AuditLog) error\n```\n\n### 2. 审计中间件\n```go\nfunc AuditMiddleware(auditSvc *AuditService) func(http.Handler) http.Handler {\n  // 自动记录所有API调用\n}\n```\n\n### 3. 审计日志查询API\n```go\n// GET /api/v1/audit-logs?user=xxx\u0026action=xxx\u0026start=xxx\u0026end=xxx\n// GET /api/v1/audit-logs/{id}\n// POST /api/v1/audit-logs/export\n```\n\n### 4. 合规报告生成\n```go\ntype ComplianceReport struct {\n  Period      string\n  UserLogins  []LoginSummary\n  PolicyChanges []ChangeRecord\n  ResponseActions []ActionRecord\n  SecurityMetrics SecurityMetrics\n}\n\nfunc (g *ReportGenerator) GenerateSOC2Report(tenantID string, period string) (*ComplianceReport, error)\nfunc (g *ReportGenerator) GenerateGDPRReport(tenantID string, period string) (*ComplianceReport, error)\n```\n\n### 5. 异常操作检测\n- 非工作时间登录告警\n- 批量删除操作告警\n- 权限提升操作告警\n\n## 验收标准\n- [ ] 所有管理操作被记录\n- [ ] 审计日志查询正常\n- [ ] CSV/PDF导出正常\n- [ ] 合规报告生成正确\n- [ ] 异常操作告警触发",
    "id": "task_1764425686906133000",
    "module": "Cloud",
    "name": "43-审计日志与合规报告",
    "simhash": 3647810996408284000,
    "status": "todo",
    "updated_at": "2025-11-30T12:19:16+08:00"
  },
  {
    "created_at": "2025-11-29T22:14:57+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: \n  - 08-Agent安全模块开发\n  - 12-云端事件接收服务\n- **被依赖任务**: 无 (安全基础设施)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - TLS: **TLS 1.3** + mTLS双向认证\n  - 加密: **AES-256-GCM** (NIST推荐)\n  - 密钥管理: HashiCorp Vault (可选)\n- **许可证**: OpenSSL 3.x (Apache 2.0)\n\n## 接口定义\n- **输入**: \n  - Agent证书请求\n  - 加密数据\n- **输出**: \n  - 签发的证书\n  - 解密数据\n\n## 任务内容\n\n实现端到端加密通信：\n\n### 1. mTLS配置 (Agent端)\n```go\n// agent/main-go/internal/security/tls.go\nfunc NewTLSConfig(certFile, keyFile, caFile string) (*tls.Config, error) {\n  cert, _ := tls.LoadX509KeyPair(certFile, keyFile)\n  caCert, _ := os.ReadFile(caFile)\n  caCertPool := x509.NewCertPool()\n  caCertPool.AppendCertsFromPEM(caCert)\n  \n  return \u0026tls.Config{\n    Certificates: []tls.Certificate{cert},\n    RootCAs:      caCertPool,\n    MinVersion:   tls.VersionTLS13,\n    CipherSuites: []uint16{\n      tls.TLS_AES_256_GCM_SHA384,\n      tls.TLS_CHACHA20_POLY1305_SHA256,\n    },\n  }, nil\n}\n```\n\n### 2. mTLS配置 (Cloud端)\n```go\n// cloud/internal/security/tls.go\nfunc NewServerTLSConfig(certFile, keyFile, caFile string) (*tls.Config, error) {\n  cert, _ := tls.LoadX509KeyPair(certFile, keyFile)\n  caCert, _ := os.ReadFile(caFile)\n  caCertPool := x509.NewCertPool()\n  caCertPool.AppendCertsFromPEM(caCert)\n  \n  return \u0026tls.Config{\n    Certificates: []tls.Certificate{cert},\n    ClientCAs:    caCertPool,\n    ClientAuth:   tls.RequireAndVerifyClientCert,\n    MinVersion:   tls.VersionTLS13,\n  }, nil\n}\n```\n\n### 3. 证书自动轮换\n```go\ntype CertRotator struct {\n  certFile    string\n  keyFile     string\n  reloadChan  chan struct{}\n  currentCert *tls.Certificate\n}\n\nfunc (r *CertRotator) Watch() {\n  watcher, _ := fsnotify.NewWatcher()\n  watcher.Add(r.certFile)\n  \n  for range watcher.Events {\n    cert, _ := tls.LoadX509KeyPair(r.certFile, r.keyFile)\n    r.currentCert = \u0026cert\n    r.reloadChan \u003c- struct{}{}\n  }\n}\n\nfunc (r *CertRotator) GetCertificate() func(*tls.ClientHelloInfo) (*tls.Certificate, error) {\n  return func(*tls.ClientHelloInfo) (*tls.Certificate, error) {\n    return r.currentCert, nil\n  }\n}\n```\n\n### 4. AES-256-GCM加密\n```go\n// cloud/pkg/crypto/aes.go\nfunc EncryptAESGCM(plaintext []byte, key []byte) ([]byte, error) {\n  block, _ := aes.NewCipher(key)\n  gcm, _ := cipher.NewGCM(block)\n  \n  nonce := make([]byte, gcm.NonceSize())\n  io.ReadFull(rand.Reader, nonce)\n  \n  ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)\n  return ciphertext, nil\n}\n\nfunc DecryptAESGCM(ciphertext []byte, key []byte) ([]byte, error) {\n  block, _ := aes.NewCipher(key)\n  gcm, _ := cipher.NewGCM(block)\n  \n  nonceSize := gcm.NonceSize()\n  nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]\n  \n  return gcm.Open(nil, nonce, ciphertext, nil)\n}\n```\n\n### 5. HashiCorp Vault集成 (可选)\n```go\ntype VaultClient struct {\n  client *vault.Client\n}\n\nfunc (v *VaultClient) GetEncryptionKey(keyName string) ([]byte, error) {\n  secret, _ := v.client.Logical().Read(\"secret/data/edr/\" + keyName)\n  return base64.StdEncoding.DecodeString(secret.Data[\"key\"].(string))\n}\n\nfunc (v *VaultClient) RotateKey(keyName string) error {\n  // 生成新密钥并存储\n}\n```\n\n### 6. 敏感数据加密存储\n```go\ntype EncryptedField struct {\n  Ciphertext []byte\n  KeyID      string\n  Version    int\n}\n\nfunc (e *EncryptedField) Decrypt(keyManager *KeyManager) ([]byte, error) {\n  key := keyManager.GetKey(e.KeyID)\n  return DecryptAESGCM(e.Ciphertext, key)\n}\n```\n\n### 项目结构\n```\nagent/main-go/internal/security/\n├── tls.go              # TLS配置\n├── cert_rotator.go     # 证书轮换\n\ncloud/internal/security/\n├── tls.go              # 服务端TLS\n├── cert.go             # 证书管理\n\ncloud/pkg/crypto/\n├── aes.go              # AES-GCM加密\n├── key_manager.go      # 密钥管理\n└── vault.go            # Vault集成\n\ndeploy/pki/\n├── ca/                 # CA证书\n├── agents/             # Agent证书模板\n└── cloud/              # Cloud证书\n```\n\n## 验收标准\n- [ ] mTLS双向认证正常\n- [ ] TLS 1.3协商成功\n- [ ] 证书轮换不中断服务\n- [ ] AES-256-GCM加解密正确\n- [ ] Vault密钥管理正常 (如启用)\n- [ ] 敏感数据加密存储",
    "id": "task_1764425697151880000",
    "module": "Cloud",
    "name": "44-安全通信与加密",
    "simhash": 10238564622767729000,
    "status": "todo",
    "updated_at": "2025-11-30T11:30:34+08:00"
  },
  {
    "created_at": "2025-11-29T22:15:06+08:00",
    "description": "实现E2E集成测试与性能测试框架，包括模拟Agent测试、告警链路验证、性能基准测试(10万Agent压测)、混沌工程测试、自动化回归测试。",
    "id": "task_1764425706953641000",
    "module": "Cloud",
    "name": "45-集成测试与性能测试",
    "simhash": 4944865823935276000,
    "status": "todo",
    "updated_at": "2025-11-29T22:15:06+08:00"
  },
  {
    "created_at": "2025-11-29T22:15:16+08:00",
    "description": "实现文档与SDK开发，包括API文档(OpenAPI 3.0)、部署运维手册、用户操作指南、Python/Go SDK封装、集成示例代码。",
    "id": "task_1764425716612938000",
    "module": "Cloud",
    "name": "46-API文档与SDK开发",
    "simhash": 5202348096015271000,
    "status": "todo",
    "updated_at": "2025-11-29T22:15:16+08:00"
  },
  {
    "created_at": "2025-11-29T22:54:55+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC 商业友好开源技术栈方案\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 02-Agent核心框架开发\n- **被依赖任务**: \n  - 48-macOS文件系统事件监控 (共用ES基础设施)\n  - 49-macOS网络事件采集 (共用ES基础设施)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md\n  - macOS事件采集: Endpoint Security Framework\n- **系统要求**: macOS 10.15+\n- **签名要求**: Apple Developer签名\n\n## 接口定义\n- **输入**: Endpoint Security事件流\n- **输出**: ECS格式进程事件 → 事件缓冲队列 → Go层\n\n## 任务内容\n\n实现macOS平台进程事件实时采集（C/ObjC实现）：\n\n### C/Objective-C核心库 (agent/core-c/src/collector/macos/)\n\n1. **ES Client创建** - es_client.m\n```objc\n#import \u003cEndpointSecurity/EndpointSecurity.h\u003e\n\nes_client_t *g_client = NULL;\n\nint es_client_init(void) {\n  es_new_client_result_t result = es_new_client(\u0026g_client, ^(es_client_t *client, const es_message_t *message) {\n    handle_es_message(client, message);\n  });\n  \n  if (result != ES_NEW_CLIENT_RESULT_SUCCESS) {\n    return -1;\n  }\n  return 0;\n}\n```\n\n2. **进程事件订阅** - es_process.m\n```objc\nint subscribe_process_events(void) {\n  es_event_type_t events[] = {\n    ES_EVENT_TYPE_NOTIFY_EXEC,\n    ES_EVENT_TYPE_NOTIFY_EXIT,\n    ES_EVENT_TYPE_NOTIFY_FORK,\n  };\n  \n  return es_subscribe(g_client, events, sizeof(events)/sizeof(es_event_type_t));\n}\n```\n\n3. **进程事件处理** - es_handler.m\n```objc\nvoid handle_es_message(es_client_t *client, const es_message_t *msg) {\n  switch (msg-\u003eevent_type) {\n    case ES_EVENT_TYPE_NOTIFY_EXEC: {\n      es_event_exec_t *exec = \u0026msg-\u003eevent.exec;\n      edr_process_event_t event = {\n        .timestamp = msg-\u003etime.tv_sec * 1000 + msg-\u003etime.tv_nsec / 1000000,\n        .pid = audit_token_to_pid(msg-\u003eprocess-\u003eaudit_token),\n        .ppid = msg-\u003eprocess-\u003eppid,\n        .event_type = PROCESS_START,\n      };\n      \n      // 获取进程路径\n      es_string_token_t path = exec-\u003etarget-\u003eexecutable-\u003epath;\n      strncpy(event.executable_path, path.data, path.length);\n      \n      // 获取命令行参数\n      // ...\n      \n      event_buffer_push(\u0026event);\n      break;\n    }\n    case ES_EVENT_TYPE_NOTIFY_EXIT: {\n      // 进程退出处理\n      break;\n    }\n  }\n}\n```\n\n4. **System Extension配置** - Info.plist\n```xml\n\u003ckey\u003eNSSystemExtensionUsageDescription\u003c/key\u003e\n\u003cstring\u003eEDR Agent需要系统扩展权限来监控进程活动\u003c/string\u003e\n\u003ckey\u003ecom.apple.developer.endpoint-security.client\u003c/key\u003e\n\u003ctrue/\u003e\n```\n\n5. **TCC权限处理** - tcc_helper.m\n```objc\nbool check_es_permission(void) {\n  // 检查是否有Endpoint Security权限\n}\n\nvoid request_es_permission(void) {\n  // 引导用户授权\n}\n```\n\n6. **事件数据结构** (与Windows/Linux一致)\n```c\n// 复用edr_events.h中的edr_process_event_t\n```\n\n### Go业务层 (agent/main-go/internal/cgo/)\n\n7. **CGO封装** - collector_darwin.go\n```go\n/*\n#cgo CFLAGS: -x objective-c\n#cgo LDFLAGS: -framework Foundation -framework EndpointSecurity\n#include \"es_client.h\"\n*/\nimport \"C\"\n\ntype DarwinCollector struct {\n  events chan *ProcessEvent\n}\n\nfunc (c *DarwinCollector) Start() error\nfunc (c *DarwinCollector) Stop() error\nfunc (c *DarwinCollector) Events() \u003c-chan *ProcessEvent\n```\n\n### 项目结构\n```\nagent/core-c/src/collector/macos/\n├── es_client.m           # ES客户端初始化\n├── es_client.h           # 头文件\n├── es_process.m          # 进程事件\n├── es_handler.m          # 事件处理\n├── tcc_helper.m          # 权限处理\n└── CMakeLists.txt\n\nagent/macos-extension/\n├── EDRExtension/\n│   ├── Info.plist\n│   └── main.swift\n└── EDRExtension.xcodeproj\n```\n\n### 代码签名配置\n```bash\n# 需要Apple Developer证书\ncodesign --sign \"Developer ID Application: Company\" \\\n  --options runtime \\\n  --entitlements entitlements.plist \\\n  EDRAgent.app\n```\n\n## 验收标准\n- [ ] 正确捕获macOS进程创建/终止事件\n- [ ] 事件字段与Windows/Linux一致 (ECS)\n- [ ] System Extension正确加载\n- [ ] TCC权限申请成功\n- [ ] 代码签名有效\n- [ ] 支持macOS 10.15+",
    "id": "task_1764428095907985000",
    "module": "Agent",
    "name": "47-macOS进程事件采集(ES Framework)",
    "simhash": 590630191750652500,
    "status": "todo",
    "updated_at": "2025-11-30T11:36:08+08:00"
  },
  {
    "created_at": "2025-11-29T22:55:08+08:00",
    "description": "实现macOS平台文件系统事件监控（C实现），包括：\n\n**C核心库实现**：\n1. FSEvents API集成（全局文件变更流）\n2. Endpoint Security文件事件：\n   - ES_EVENT_TYPE_NOTIFY_CREATE\n   - ES_EVENT_TYPE_NOTIFY_WRITE\n   - ES_EVENT_TYPE_NOTIFY_RENAME\n   - ES_EVENT_TYPE_NOTIFY_UNLINK\n3. 文件事件与进程关联（audit token）\n4. 敏感路径监控（/Applications, ~/Library等）\n\n**Go业务层**：\n5. CGO调用文件事件获取\n6. 监控目录配置\n7. 与Windows/Linux事件格式统一\n\n技术选型（C+Go）：\n- C + FSEvents (macOS原生)\n- C + Endpoint Security Framework (细粒度)\n- CGO - Go调用\n\n备选方案（Rust）：\n- fsevent-rust (MIT)\n\n验收标准：\n- 监控指定目录文件变更\n- 事件包含操作进程信息\n- 与其他平台格式一致",
    "id": "task_1764428108927198000",
    "module": "Agent",
    "name": "48-macOS文件系统事件监控",
    "simhash": 590553225936709000,
    "status": "todo",
    "updated_at": "2025-11-29T23:15:12+08:00"
  },
  {
    "created_at": "2025-11-29T22:55:21+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 2 (Sprint 6-8)\n- **依赖任务**: 47-macOS进程事件采集\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md - macOS网络采集: Network Extension Framework\n- **系统要求**: macOS 10.15+, Apple Developer签名 + System Extension权限\n- **事件格式**: ECS兼容\n\n## 接口定义\n- **输入**: Network Extension事件流 (NEFilterDataProvider)\n- **输出**: ECS格式网络事件 → 事件缓冲队列\n- **Go层接口**: MacOSNetworkCollector.Start/Stop/Events()\n\n## 任务内容\n实现macOS平台网络事件采集（C/ObjC + Go CGO）：\n\n1. **NEFilterDataProvider实现** - 继承NEFilterDataProvider处理网络流\n2. **TCP/UDP连接监控** - 处理出入站连接事件\n3. **DNS请求采集** - 监控端口53流量\n4. **进程关联** - 通过audit_token获取发起进程信息\n5. **System Extension配置** - Entitlements和Info.plist\n6. **CGO封装** - Go层调用ObjC网络采集库\n\n## 验收标准\n- [ ] 捕获出入站网络连接\n- [ ] DNS查询记录完整\n- [ ] 能关联到发起进程\n- [ ] 与Windows/Linux事件格式一致\n- [ ] Network Extension正确加载",
    "id": "task_1764428121330850000",
    "module": "Agent",
    "name": "49-macOS网络事件采集(NEProvider)",
    "simhash": 590660978076230500,
    "status": "todo",
    "updated_at": "2025-11-30T12:28:32+08:00"
  },
  {
    "created_at": "2025-11-29T23:15:40+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-B2 (Sprint 2-4)\n- **依赖任务**: 05-Linux进程事件采集(eBPF)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md - Linux文件监控: inotify / fanotify\n- **事件格式**: ECS兼容\n- **权限要求**: fanotify需要CAP_SYS_ADMIN\n\n## 接口定义\n- **输入**: inotify/fanotify系统事件\n- **输出**: ECS格式文件事件 → 事件缓冲队列\n- **Go层接口**: LinuxFileCollector.Start/AddWatch/Events()\n\n## 任务内容\n实现Linux平台文件系统事件监控（C + Go CGO）：\n\n1. **inotify API封装** - 初始化、添加watch、递归子目录\n2. **fanotify API封装** - 文件系统级监控（备选方案）\n3. **事件处理循环** - 读取事件、解析路径、映射操作类型\n4. **watch数量管理** - 处理max_user_watches限制\n5. **监控目录配置** - include/exclude路径模式\n6. **CGO封装** - Go层调用C文件监控库\n\n## 验收标准\n- [ ] 监控指定目录文件变更\n- [ ] 递归监控子目录\n- [ ] 事件包含完整路径和操作类型\n- [ ] 支持配置监控范围\n- [ ] 与Windows/macOS事件格式一致",
    "id": "task_1764429340449002000",
    "module": "Agent",
    "name": "50-Linux文件系统事件监控",
    "simhash": 590631291262283100,
    "status": "todo",
    "updated_at": "2025-11-30T12:28:43+08:00"
  },
  {
    "created_at": "2025-11-29T23:15:57+08:00",
    "description": "实现Linux平台网络连接事件采集（C实现），包括：\n\n**C核心库实现**：\n1. eBPF sock跟踪程序\n2. TCP连接建立/关闭事件\n3. UDP连接事件\n4. DNS请求采集（端口53流量）\n5. 网络事件与进程关联（pid/comm）\n6. Fallback: /proc/net/tcp 解析\n\n**Go业务层**：\n7. CGO调用网络事件获取\n8. 与Windows/macOS事件格式统一\n9. 连接方向判断（入站/出站）\n\n技术选型（C+Go）：\n- C + eBPF (libbpf LGPL 2.1，动态链接)\n- C + procfs解析（无eBPF环境）\n- CGO - Go调用\n\n验收标准：\n- 能捕获出站TCP连接\n- 能采集DNS查询域名\n- 事件能关联到发起进程",
    "id": "task_1764429357264202000",
    "module": "Agent",
    "name": "51-Linux网络连接事件采集",
    "simhash": 590775327352629900,
    "status": "todo",
    "updated_at": "2025-11-29T23:15:57+08:00"
  },
  {
    "created_at": "2025-11-29T23:16:11+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-B1 (Sprint 2-4)\n- **依赖任务**: 04-Windows进程事件采集(ETW)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md - Windows文件监控: ReadDirectoryChangesW\n- **事件格式**: ECS兼容\n\n## 接口定义\n- **输入**: ReadDirectoryChangesW异步事件\n- **输出**: ECS格式文件事件 → 事件缓冲队列\n- **Go层接口**: WindowsFileCollector.AddWatch/RemoveWatch/Events()\n\n## 任务内容\n实现Windows平台文件系统事件监控（C + Go CGO）：\n\n1. **ReadDirectoryChangesW封装** - 异步目录监控、OVERLAPPED结构\n2. **目录监控回调** - 解析FILE_NOTIFY_INFORMATION、映射操作类型\n3. **递归子目录监控** - bWatchSubtree参数\n4. **文件哈希计算** - SHA256（使用CNG API或OpenSSL）\n5. **监控目录配置** - include/exclude路径模式\n6. **高频变更防抖** - 100ms内重复事件过滤\n7. **CGO封装** - Go层调用C文件监控库\n\n## 验收标准\n- [ ] 监控指定目录文件变更\n- [ ] 递归监控子目录\n- [ ] 事件包含完整路径和操作类型\n- [ ] 高频变更防抖生效\n- [ ] 与Linux/macOS事件格式一致",
    "id": "task_1764429371294813000",
    "module": "Agent",
    "name": "52-Windows文件系统事件监控",
    "simhash": 590623594680887300,
    "status": "todo",
    "updated_at": "2025-11-30T12:28:54+08:00"
  },
  {
    "created_at": "2025-11-29T23:16:29+08:00",
    "description": "## 任务上下文\n- **所属项目**: EDR-POC\n- **综述任务**: task_1764139809165290791\n- **Phase**: Phase 1-B1 (Sprint 2-4)\n- **依赖任务**: 04-Windows进程事件采集(ETW)\n\n## 关键规范引用\n- **技术决策**: 参考 决策项.md - Windows网络采集: ETW Network Provider\n- **事件格式**: ECS兼容\n- **ETW Provider**: Microsoft-Windows-Kernel-Network, Microsoft-Windows-DNS-Client\n\n## 接口定义\n- **输入**: ETW网络事件 (TcpIp/Connect, TcpIp/Accept, DNS Query等)\n- **输出**: ECS格式网络事件 → 事件缓冲队列\n- **Go层接口**: WindowsNetworkCollector.Start/Stop/Events()\n\n## 任务内容\n实现Windows平台网络连接事件采集（C + Go CGO）：\n\n1. **ETW Network Provider消费者** - 订阅Kernel-Network和TCPIP Provider\n2. **ETW DNS Provider** - 订阅DNS-Client Provider采集DNS查询\n3. **ETW Session管理** - StartTrace/EnableTraceEx2/ProcessTrace\n4. **网络事件与进程关联** - 通过PID查询进程名\n5. **连接方向判断** - Connect=出站, Accept=入站\n6. **CGO封装** - Go层调用C网络采集库\n\n## 验收标准\n- [ ] 能捕获出站TCP连接\n- [ ] 能捕获入站连接\n- [ ] 能采集DNS查询域名\n- [ ] 事件能关联到发起进程\n- [ ] 与Linux/macOS事件格式一致",
    "id": "task_1764429389625080000",
    "module": "Agent",
    "name": "53-Windows网络连接事件采集",
    "simhash": 590775327285519000,
    "status": "todo",
    "updated_at": "2025-11-30T12:29:05+08:00"
  }
]